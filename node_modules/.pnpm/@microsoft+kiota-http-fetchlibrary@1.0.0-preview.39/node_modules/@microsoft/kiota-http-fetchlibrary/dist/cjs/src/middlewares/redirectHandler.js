"use strict";
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RedirectHandler = void 0;
const tslib_1 = require("tslib");
/**
 * @module RedirectHandler
 */
const kiota_abstractions_1 = require("@microsoft/kiota-abstractions");
const api_1 = require("@opentelemetry/api");
const observabilityOptions_1 = require("../observabilityOptions");
const redirectHandlerOptions_1 = require("./options/redirectHandlerOptions");
/**
 * @class
 * Class
 * @implements Middleware
 * Class representing RedirectHandler
 */
class RedirectHandler {
    /**
     *
     * @public
     * @constructor
     * To create an instance of RedirectHandler
     * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance
     * @returns An instance of RedirectHandler
     */
    constructor(options = new redirectHandlerOptions_1.RedirectHandlerOptions()) {
        this.options = options;
        if (!options) {
            throw new Error("The options parameter is required.");
        }
    }
    /**
     * @private
     * To check whether the response has the redirect status code or not
     * @param {Response} response - The response object
     * @returns A boolean representing whether the response contains the redirect status code or not
     */
    isRedirect(response) {
        return RedirectHandler.REDIRECT_STATUS_CODES.has(response.status);
    }
    /**
     * @private
     * To check whether the response has location header or not
     * @param {Response} response - The response object
     * @returns A boolean representing the whether the response has location header or not
     */
    hasLocationHeader(response) {
        return response.headers.has(RedirectHandler.LOCATION_HEADER);
    }
    /**
     * @private
     * To get the redirect url from location header in response object
     * @param {Response} response - The response object
     * @returns A redirect url from location header
     */
    getLocationHeader(response) {
        return response.headers.get(RedirectHandler.LOCATION_HEADER);
    }
    /**
     * @private
     * To check whether the given url is a relative url or not
     * @param {string} url - The url string value
     * @returns A boolean representing whether the given url is a relative url or not
     */
    isRelativeURL(url) {
        return url.indexOf("://") === -1;
    }
    /**
     * @private
     * To check whether the authorization header in the request should be dropped for consequent redirected requests
     * @param {string} requestUrl - The request url value
     * @param {string} redirectUrl - The redirect url value
     * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests
     */
    shouldDropAuthorizationHeader(requestUrl, redirectUrl) {
        const schemeHostRegex = /^[A-Za-z].+?:\/\/.+?(?=\/|$)/;
        const requestMatches = schemeHostRegex.exec(requestUrl);
        let requestAuthority;
        let redirectAuthority;
        if (requestMatches !== null) {
            requestAuthority = requestMatches[0];
        }
        const redirectMatches = schemeHostRegex.exec(redirectUrl);
        if (redirectMatches !== null) {
            redirectAuthority = redirectMatches[0];
        }
        return typeof requestAuthority !== "undefined" && typeof redirectAuthority !== "undefined" && requestAuthority !== redirectAuthority;
    }
    /**
     * @private
     * @async
     * To execute the next middleware and to handle in case of redirect response returned by the server
     * @param {Context} context - The context object
     * @param {number} redirectCount - The redirect count value
     * @param {Record<string, RequestOption>} [requestOptions = {}] - The request options
     * @param {RedirectHandlerOptions} currentOptions - The redirect handler options instance
     * @param {string} tracerName - The name to use for the tracer
     * @returns A promise that resolves to nothing
     */
    executeWithRedirect(url, fetchRequestInit, redirectCount, currentOptions, requestOptions, tracerName) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield ((_a = this.next) === null || _a === void 0 ? void 0 : _a.execute(url, fetchRequestInit, requestOptions));
            if (!response) {
                throw new Error("Response is undefined");
            }
            if (redirectCount < currentOptions.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && currentOptions.shouldRedirect(response)) {
                ++redirectCount;
                if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {
                    fetchRequestInit["method"] = kiota_abstractions_1.HttpMethod.GET;
                    delete fetchRequestInit.body;
                }
                else {
                    const redirectUrl = this.getLocationHeader(response);
                    if (redirectUrl) {
                        if (fetchRequestInit.headers && !this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(url, redirectUrl)) {
                            delete fetchRequestInit.headers[RedirectHandler.AUTHORIZATION_HEADER];
                        }
                        url = redirectUrl;
                    }
                }
                if (tracerName) {
                    return api_1.trace.getTracer(tracerName).startActiveSpan(`redirectHandler - redirect ${redirectCount}`, (span) => {
                        try {
                            span.setAttribute("com.microsoft.kiota.handler.redirect.count", redirectCount);
                            span.setAttribute("http.status_code", response.status);
                            return this.executeWithRedirect(url, fetchRequestInit, redirectCount, currentOptions, requestOptions);
                        }
                        finally {
                            span.end();
                        }
                    });
                }
                return yield this.executeWithRedirect(url, fetchRequestInit, redirectCount, currentOptions, requestOptions);
            }
            else {
                return response;
            }
        });
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(url, requestInit, requestOptions) {
        const redirectCount = 0;
        let currentOptions = this.options;
        if (requestOptions && requestOptions[redirectHandlerOptions_1.RedirectHandlerOptionKey]) {
            currentOptions = requestOptions[redirectHandlerOptions_1.RedirectHandlerOptionKey];
        }
        requestInit.redirect = RedirectHandler.MANUAL_REDIRECT;
        const obsOptions = (0, observabilityOptions_1.getObservabilityOptionsFromRequest)(requestOptions);
        if (obsOptions) {
            return api_1.trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("redirectHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.redirect.enable", true);
                    return this.executeWithRedirect(url, requestInit, redirectCount, currentOptions, requestOptions, obsOptions.getTracerInstrumentationName());
                }
                finally {
                    span.end();
                }
            });
        }
        return this.executeWithRedirect(url, requestInit, redirectCount, currentOptions, requestOptions);
    }
}
exports.RedirectHandler = RedirectHandler;
/**
 * @private
 * @static
 * A member holding the array of redirect status codes
 */
RedirectHandler.REDIRECT_STATUS_CODES = new Set([
    301, // Moved Permanently
    302, // Found
    303, // See Other
    307, // Temporary Permanently
    308, // Moved Permanently
]);
/**
 * @private
 * @static
 * A member holding SeeOther status code
 */
RedirectHandler.STATUS_CODE_SEE_OTHER = 303;
/**
 * @private
 * @static
 * A member holding the name of the location header
 */
RedirectHandler.LOCATION_HEADER = "Location";
/**
 * @private
 * @static
 * A member representing the authorization header name
 */
RedirectHandler.AUTHORIZATION_HEADER = "Authorization";
/**
 * @private
 * @static
 * A member holding the manual redirect value
 */
RedirectHandler.MANUAL_REDIRECT = "manual";
