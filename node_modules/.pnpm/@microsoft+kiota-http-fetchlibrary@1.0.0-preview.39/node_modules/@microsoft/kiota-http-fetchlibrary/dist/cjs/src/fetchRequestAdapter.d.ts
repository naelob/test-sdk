import { type AuthenticationProvider, type BackingStoreFactory, type DateOnly, type Duration, type ErrorMappings, type Parsable, type ParsableFactory, type ParseNodeFactory, type PrimitiveTypesForDeserialization, type PrimitiveTypesForDeserializationType, type RequestAdapter, type RequestInformation, type SerializationWriterFactory, type TimeOnly } from "@microsoft/kiota-abstractions";
import { HttpClient } from "./httpClient";
import { type ObservabilityOptions } from "./observabilityOptions";
/**
 * Request adapter implementation for the fetch API.
 */
export declare class FetchRequestAdapter implements RequestAdapter {
    readonly authenticationProvider: AuthenticationProvider;
    private parseNodeFactory;
    private serializationWriterFactory;
    private readonly httpClient;
    /** The base url for every request. */
    baseUrl: string;
    getSerializationWriterFactory(): SerializationWriterFactory;
    private readonly observabilityOptions;
    /**
     * Instantiates a new request adapter.
     * @param authenticationProvider the authentication provider to use.
     * @param parseNodeFactory the parse node factory to deserialize responses.
     * @param serializationWriterFactory the serialization writer factory to use to serialize request bodies.
     * @param httpClient the http client to use to execute requests.
     * @param observabilityOptions the observability options to use.
     */
    constructor(authenticationProvider: AuthenticationProvider, parseNodeFactory?: ParseNodeFactory, serializationWriterFactory?: SerializationWriterFactory, httpClient?: HttpClient, observabilityOptions?: ObservabilityOptions);
    private getResponseContentType;
    private getResponseHandler;
    private static readonly responseTypeAttributeKey;
    sendCollectionOfPrimitiveAsync: <ResponseType_1 extends string | number | boolean | DateOnly | Date | Duration | TimeOnly>(requestInfo: RequestInformation, responseType: Exclude<PrimitiveTypesForDeserialization, "ArrayBuffer">, errorMappings: ErrorMappings | undefined) => Promise<ResponseType_1[] | undefined>;
    sendCollectionAsync: <ModelType extends Parsable>(requestInfo: RequestInformation, deserialization: ParsableFactory<ModelType>, errorMappings: ErrorMappings | undefined) => Promise<ModelType[] | undefined>;
    private startTracingSpan;
    static readonly eventResponseHandlerInvokedKey = "com.microsoft.kiota.response_handler_invoked";
    sendAsync: <ModelType extends Parsable>(requestInfo: RequestInformation, deserializer: ParsableFactory<ModelType>, errorMappings: ErrorMappings | undefined) => Promise<ModelType | undefined>;
    sendPrimitiveAsync: <ResponseType_1 extends PrimitiveTypesForDeserializationType>(requestInfo: RequestInformation, responseType: PrimitiveTypesForDeserialization, errorMappings: ErrorMappings | undefined) => Promise<ResponseType_1 | undefined>;
    sendNoResponseContentAsync: (requestInfo: RequestInformation, errorMappings: ErrorMappings | undefined) => Promise<void>;
    enableBackingStore: (backingStoreFactory?: BackingStoreFactory | undefined) => void;
    private getRootParseNode;
    private shouldReturnUndefined;
    /** purges the response body if it hasn't been read to release the connection to the server */
    private purgeResponseBody;
    static readonly errorMappingFoundAttributeName = "com.microsoft.kiota.error.mapping_found";
    static readonly errorBodyFoundAttributeName = "com.microsoft.kiota.error.body_found";
    private throwIfFailedResponse;
    private getHttpResponseMessage;
    static readonly authenticateChallengedEventKey = "com.microsoft.kiota.authenticate_challenge_received";
    private retryCAEResponseIfRequired;
    private getClaimsFromResponse;
    private setBaseUrlForRequestInformation;
    private getRequestFromRequestInformation;
    private foldHeaderValue;
    /**
     * @inheritdoc
     */
    convertToNativeRequestAsync: <T>(requestInfo: RequestInformation) => Promise<T>;
}
//# sourceMappingURL=fetchRequestAdapter.d.ts.map