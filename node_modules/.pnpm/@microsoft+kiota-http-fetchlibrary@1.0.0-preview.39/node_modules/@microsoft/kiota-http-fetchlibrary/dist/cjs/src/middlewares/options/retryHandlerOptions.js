"use strict";
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryHandlerOptions = exports.RetryHandlerOptionKey = void 0;
exports.RetryHandlerOptionKey = "RetryHandlerOptionKey";
/**
 * @class
 * @implements RequestOption
 * Options
 * Class for RetryHandlerOptions
 */
class RetryHandlerOptions {
    /**
     * @public
     * @constructor
     * To create an instance of RetryHandlerOptions
     * @param {RetryHandlerOptionsParams} options - The RetryHandlerOptionsParams object
     * @returns An instance of RetryHandlerOptions
     * @example	const options = new RetryHandlerOptions({ maxRetries: 4 });
     */
    constructor(options = {}) {
        var _a, _b, _c;
        if (options.delay !== undefined && options.delay > RetryHandlerOptions.MAX_DELAY) {
            throw this.createError(`Delay should not be more than ${RetryHandlerOptions.MAX_DELAY}`, "MaxLimitExceeded");
        }
        if (options.maxRetries !== undefined && options.maxRetries > RetryHandlerOptions.MAX_MAX_RETRIES) {
            throw this.createError(`MaxRetries should not be more than ${RetryHandlerOptions.MAX_MAX_RETRIES}`, "MaxLimitExceeded");
        }
        if (options.delay !== undefined && options.delay < 0) {
            throw this.createError(`Delay should not be negative`, "MinExpectationNotMet");
        }
        if (options.maxRetries !== undefined && options.maxRetries < 0) {
            throw this.createError(`MaxRetries should not be negative`, "MinExpectationNotMet");
        }
        this.delay = Math.min((_a = options.delay) !== null && _a !== void 0 ? _a : RetryHandlerOptions.DEFAULT_DELAY, RetryHandlerOptions.MAX_DELAY);
        this.maxRetries = Math.min((_b = options.maxRetries) !== null && _b !== void 0 ? _b : RetryHandlerOptions.DEFAULT_MAX_RETRIES, RetryHandlerOptions.MAX_MAX_RETRIES);
        this.shouldRetry = (_c = options.shouldRetry) !== null && _c !== void 0 ? _c : RetryHandlerOptions.defaultShouldRetry;
    }
    /**
     * @private
     * Creates an error object with a message and name
     * @param {string} message - The error message
     * @param {string} name - The error name
     * @returns An error object
     */
    createError(message, name) {
        const error = new Error(message);
        error.name = name;
        return error;
    }
    /**
     * @public
     * To get the maximum delay
     * @returns A maximum delay
     */
    getMaxDelay() {
        return RetryHandlerOptions.MAX_DELAY;
    }
    getKey() {
        return exports.RetryHandlerOptionKey;
    }
}
exports.RetryHandlerOptions = RetryHandlerOptions;
/**
 * @private
 * @static
 * A member holding default delay value in seconds
 */
RetryHandlerOptions.DEFAULT_DELAY = 3;
/**
 * @private
 * @static
 * A member holding default maxRetries value
 */
RetryHandlerOptions.DEFAULT_MAX_RETRIES = 3;
/**
 * @private
 * @static
 * A member holding maximum delay value in seconds
 */
RetryHandlerOptions.MAX_DELAY = 180;
/**
 * @private
 * @static
 * A member holding maximum maxRetries value
 */
RetryHandlerOptions.MAX_MAX_RETRIES = 10;
/**
 * @private
 * A member holding default shouldRetry callback
 */
RetryHandlerOptions.defaultShouldRetry = () => true;
