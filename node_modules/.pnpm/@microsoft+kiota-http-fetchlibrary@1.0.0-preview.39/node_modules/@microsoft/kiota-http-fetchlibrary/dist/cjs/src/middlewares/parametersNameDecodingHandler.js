"use strict";
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParametersNameDecodingHandler = void 0;
const api_1 = require("@opentelemetry/api");
const observabilityOptions_1 = require("../observabilityOptions");
const parametersNameDecodingOptions_1 = require("./options/parametersNameDecodingOptions");
/**
 * @module ParametersNameDecodingHandler
 */
class ParametersNameDecodingHandler {
    /**
     * @public
     * @constructor
     * To create an instance of ParametersNameDecodingHandler
     * @param {ParametersNameDecodingHandlerOptions} [options = new ParametersNameDecodingHandlerOptions()] - The parameters name decoding handler options value
     */
    constructor(options = new parametersNameDecodingOptions_1.ParametersNameDecodingHandlerOptions()) {
        this.options = options;
        if (!options) {
            throw new Error("The options parameter is required.");
        }
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {string} url - The url to be fetched
     * @param {FetchRequestInit} requestInit - The request init object
     * @param {Record<string, RequestOption>} [requestOptions] - The request options
     * @returns A Promise that resolves to nothing
     */
    execute(url, requestInit, requestOptions) {
        let currentOptions = this.options;
        if (requestOptions && requestOptions[parametersNameDecodingOptions_1.ParametersNameDecodingHandlerOptionsKey]) {
            currentOptions = requestOptions[parametersNameDecodingOptions_1.ParametersNameDecodingHandlerOptionsKey];
        }
        const obsOptions = (0, observabilityOptions_1.getObservabilityOptionsFromRequest)(requestOptions);
        if (obsOptions) {
            return api_1.trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("parametersNameDecodingHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.parameters_name_decoding.enable", currentOptions.enable);
                    return this.decodeParameters(url, requestInit, currentOptions, requestOptions);
                }
                finally {
                    span.end();
                }
            });
        }
        return this.decodeParameters(url, requestInit, currentOptions, requestOptions);
    }
    decodeParameters(url, requestInit, currentOptions, requestOptions) {
        var _a, _b;
        let updatedUrl = url;
        if (currentOptions && currentOptions.enable && url.indexOf("%") > -1 && currentOptions.charactersToDecode && currentOptions.charactersToDecode.length > 0) {
            currentOptions.charactersToDecode.forEach((character) => {
                updatedUrl = updatedUrl.replace(new RegExp(`%${character.charCodeAt(0).toString(16)}`, "gi"), character);
            });
        }
        return (_b = (_a = this.next) === null || _a === void 0 ? void 0 : _a.execute(updatedUrl, requestInit, requestOptions)) !== null && _b !== void 0 ? _b : Promise.reject(new Error("The next middleware is not set."));
    }
}
exports.ParametersNameDecodingHandler = ParametersNameDecodingHandler;
