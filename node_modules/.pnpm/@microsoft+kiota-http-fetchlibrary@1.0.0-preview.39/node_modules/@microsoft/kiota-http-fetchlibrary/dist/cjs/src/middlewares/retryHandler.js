"use strict";
/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RetryHandler = void 0;
const tslib_1 = require("tslib");
/**
 * @module RetryHandler
 */
const kiota_abstractions_1 = require("@microsoft/kiota-abstractions");
const api_1 = require("@opentelemetry/api");
const observabilityOptions_1 = require("../observabilityOptions");
const headersUtil_1 = require("../utils/headersUtil");
const retryHandlerOptions_1 = require("./options/retryHandlerOptions");
/**
 * @class
 * @implements Middleware
 * Class for RetryHandler
 */
class RetryHandler {
    /**
     * @public
     * @constructor
     * To create an instance of RetryHandler
     * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value
     * @returns An instance of RetryHandler
     */
    constructor(options = new retryHandlerOptions_1.RetryHandlerOptions()) {
        this.options = options;
        if (!options) {
            throw new Error("The options parameter is required.");
        }
    }
    /**
     *
     * @private
     * To check whether the response has the retry status code
     * @param {Response} response - The response object
     * @returns Whether the response has retry status code or not
     */
    isRetry(response) {
        return RetryHandler.RETRY_STATUS_CODES.has(response.status);
    }
    /**
     * @private
     * To check whether the payload is buffered or not
     * @param {RequestInit} options - The options of a request
     * @returns Whether the payload is buffered or not
     */
    isBuffered(options) {
        var _a;
        const method = options.method;
        const isPutPatchOrPost = method === kiota_abstractions_1.HttpMethod.PUT || method === kiota_abstractions_1.HttpMethod.PATCH || method === kiota_abstractions_1.HttpMethod.POST;
        if (isPutPatchOrPost) {
            const isStream = ((_a = (0, headersUtil_1.getRequestHeader)(options, "content-type")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "application/octet-stream";
            if (isStream) {
                return false;
            }
        }
        return true;
    }
    /**
     * @private
     * To get the delay for a retry
     * @param {Response} response - The response object
     * @param {number} retryAttempts - The current attempt count
     * @param {number} delay - The delay value in seconds
     * @returns A delay for a retry
     */
    getDelay(response, retryAttempts, delay) {
        const getRandomness = () => Number(Math.random().toFixed(3));
        const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
        let newDelay;
        if (retryAfter !== null) {
            // Retry-After: <http-date>
            if (Number.isNaN(Number(retryAfter))) {
                newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);
            }
            else {
                // Retry-After: <delay-seconds>
                newDelay = Number(retryAfter);
            }
        }
        else {
            // Adding randomness to avoid retrying at a same
            newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();
        }
        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
    }
    /**
     * @private
     * To get an exponential back off value
     * @param {number} attempts - The current attempt count
     * @returns An exponential back off value
     */
    getExponentialBackOffTime(attempts) {
        return Math.round((1 / 2) * (Math.pow(2, attempts) - 1));
    }
    /**
     * @private
     * @async
     * To add delay for the execution
     * @param {number} delaySeconds - The delay value in seconds
     * @returns Nothing
     */
    sleep(delaySeconds) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const delayMilliseconds = delaySeconds * 1000;
            return new Promise((resolve) => setTimeout(resolve, delayMilliseconds)); // browser or node
        });
    }
    /**
     * @private
     * @async
     * To execute the middleware with retries
     * @param {Context} context - The context object
     * @param {number} retryAttempts - The current attempt count
     * @param {Record<string, RequestOption>} [requestOptions = {}] - The request options
     * @param {RetryHandlerOptions} currentOptions - The retry middleware options instance
     * @param {string} tracerName - The name to use for the tracer
     * @returns A Promise that resolves to nothing
     */
    executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions, tracerName) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = yield ((_a = this.next) === null || _a === void 0 ? void 0 : _a.execute(url, fetchRequestInit, requestOptions));
            if (!response) {
                throw new Error("Response is undefined");
            }
            if (retryAttempts < currentOptions.maxRetries && this.isRetry(response) && this.isBuffered(fetchRequestInit) && currentOptions.shouldRetry(currentOptions.delay, retryAttempts, url, fetchRequestInit, response)) {
                ++retryAttempts;
                (0, headersUtil_1.setRequestHeader)(fetchRequestInit, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
                if (response) {
                    const delay = this.getDelay(response, retryAttempts, currentOptions.delay);
                    yield this.sleep(delay);
                }
                if (tracerName) {
                    return yield api_1.trace.getTracer(tracerName).startActiveSpan(`retryHandler - attempt ${retryAttempts}`, (span) => {
                        try {
                            span.setAttribute("http.retry_count", retryAttempts);
                            span.setAttribute("http.status_code", response.status);
                            return this.executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions);
                        }
                        finally {
                            span.end();
                        }
                    });
                }
                return yield this.executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions);
            }
            else {
                return response;
            }
        });
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(url, requestInit, requestOptions) {
        const retryAttempts = 0;
        let currentOptions = this.options;
        if (requestOptions && requestOptions[retryHandlerOptions_1.RetryHandlerOptionKey]) {
            currentOptions = requestOptions[retryHandlerOptions_1.RetryHandlerOptionKey];
        }
        const obsOptions = (0, observabilityOptions_1.getObservabilityOptionsFromRequest)(requestOptions);
        if (obsOptions) {
            return api_1.trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("retryHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.retry.enable", true);
                    return this.executeWithRetry(url, requestInit, retryAttempts, currentOptions, requestOptions, obsOptions.getTracerInstrumentationName());
                }
                finally {
                    span.end();
                }
            });
        }
        return this.executeWithRetry(url, requestInit, retryAttempts, currentOptions, requestOptions);
    }
}
exports.RetryHandler = RetryHandler;
/**
 * @private
 * @static
 * A list of status codes that needs to be retried
 */
RetryHandler.RETRY_STATUS_CODES = new Set([
    429, // Too many requests
    503, // Service unavailable
    504, // Gateway timeout
]);
/**
 * @private
 * @static
 * A member holding the name of retry attempt header
 */
RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
/**
 * @private
 * @static
 * A member holding the name of retry after header
 */
RetryHandler.RETRY_AFTER_HEADER = "Retry-After";
