import { BackingStoreFactorySingleton, DefaultApiError, enableBackingStoreForParseNodeFactory, enableBackingStoreForSerializationWriterFactory, ParseNodeFactoryRegistry, ResponseHandlerOptionKey, SerializationWriterFactoryRegistry } from "@microsoft/kiota-abstractions";
import { SpanStatusCode, trace } from "@opentelemetry/api";
import { HttpClient } from "./httpClient";
import { ObservabilityOptionsImpl } from "./observabilityOptions";
/**
 * Request adapter implementation for the fetch API.
 */
export class FetchRequestAdapter {
    getSerializationWriterFactory() {
        return this.serializationWriterFactory;
    }
    /**
     * Instantiates a new request adapter.
     * @param authenticationProvider the authentication provider to use.
     * @param parseNodeFactory the parse node factory to deserialize responses.
     * @param serializationWriterFactory the serialization writer factory to use to serialize request bodies.
     * @param httpClient the http client to use to execute requests.
     * @param observabilityOptions the observability options to use.
     */
    constructor(authenticationProvider, parseNodeFactory = ParseNodeFactoryRegistry.defaultInstance, serializationWriterFactory = SerializationWriterFactoryRegistry.defaultInstance, httpClient = new HttpClient(), observabilityOptions = new ObservabilityOptionsImpl()) {
        this.authenticationProvider = authenticationProvider;
        this.parseNodeFactory = parseNodeFactory;
        this.serializationWriterFactory = serializationWriterFactory;
        this.httpClient = httpClient;
        /** The base url for every request. */
        this.baseUrl = "";
        this.getResponseContentType = (response) => {
            var _a;
            const header = (_a = response.headers.get("content-type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (!header)
                return undefined;
            const segments = header.split(";");
            if (segments.length === 0)
                return undefined;
            else
                return segments[0];
        };
        this.getResponseHandler = (response) => {
            const options = response.getRequestOptions();
            const responseHandlerOption = options[ResponseHandlerOptionKey];
            return responseHandlerOption === null || responseHandlerOption === void 0 ? void 0 : responseHandlerOption.responseHandler;
        };
        this.sendCollectionOfPrimitiveAsync = (requestInfo, responseType, errorMappings) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            return this.startTracingSpan(requestInfo, "sendCollectionOfPrimitiveAsync", async (span) => {
                try {
                    const response = await this.getHttpResponseMessage(requestInfo, span);
                    const responseHandler = this.getResponseHandler(requestInfo);
                    if (responseHandler) {
                        span.addEvent(FetchRequestAdapter.eventResponseHandlerInvokedKey);
                        return await responseHandler.handleResponseAsync(response, errorMappings);
                    }
                    else {
                        try {
                            await this.throwIfFailedResponse(response, errorMappings, span);
                            if (this.shouldReturnUndefined(response))
                                return undefined;
                            switch (responseType) {
                                case "string":
                                case "number":
                                case "boolean":
                                case "Date":
                                    // eslint-disable-next-line no-case-declarations
                                    const rootNode = await this.getRootParseNode(response);
                                    return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan(`getCollectionOf${responseType}Value`, (deserializeSpan) => {
                                        try {
                                            span.setAttribute(FetchRequestAdapter.responseTypeAttributeKey, responseType);
                                            if (responseType === "string") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "number") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "boolean") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "Date") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "Duration") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "DateOnly") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else if (responseType === "TimeOnly") {
                                                return rootNode.getCollectionOfPrimitiveValues();
                                            }
                                            else {
                                                throw new Error("unexpected type to deserialize");
                                            }
                                        }
                                        finally {
                                            deserializeSpan.end();
                                        }
                                    });
                            }
                        }
                        finally {
                            await this.purgeResponseBody(response);
                        }
                    }
                }
                finally {
                    span.end();
                }
            });
        };
        this.sendCollectionAsync = (requestInfo, deserialization, errorMappings) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            return this.startTracingSpan(requestInfo, "sendCollectionAsync", async (span) => {
                try {
                    const response = await this.getHttpResponseMessage(requestInfo, span);
                    const responseHandler = this.getResponseHandler(requestInfo);
                    if (responseHandler) {
                        span.addEvent(FetchRequestAdapter.eventResponseHandlerInvokedKey);
                        return await responseHandler.handleResponseAsync(response, errorMappings);
                    }
                    else {
                        try {
                            await this.throwIfFailedResponse(response, errorMappings, span);
                            if (this.shouldReturnUndefined(response))
                                return undefined;
                            const rootNode = await this.getRootParseNode(response);
                            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getCollectionOfObjectValues", (deserializeSpan) => {
                                try {
                                    const result = rootNode.getCollectionOfObjectValues(deserialization);
                                    span.setAttribute(FetchRequestAdapter.responseTypeAttributeKey, "object[]");
                                    return result;
                                }
                                finally {
                                    deserializeSpan.end();
                                }
                            });
                        }
                        finally {
                            await this.purgeResponseBody(response);
                        }
                    }
                }
                finally {
                    span.end();
                }
            });
        };
        this.startTracingSpan = (requestInfo, methodName, callback) => {
            var _a;
            const urlTemplate = decodeURIComponent((_a = requestInfo.urlTemplate) !== null && _a !== void 0 ? _a : "");
            const telemetryPathValue = urlTemplate.replace(/\{\?[^}]+\}/gi, "");
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan(`${methodName} - ${telemetryPathValue}`, async (span) => {
                try {
                    span.setAttribute("http.uri_template", urlTemplate);
                    return await callback(span);
                }
                finally {
                    span.end();
                }
            });
        };
        this.sendAsync = (requestInfo, deserializer, errorMappings) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            return this.startTracingSpan(requestInfo, "sendAsync", async (span) => {
                try {
                    const response = await this.getHttpResponseMessage(requestInfo, span);
                    const responseHandler = this.getResponseHandler(requestInfo);
                    if (responseHandler) {
                        span.addEvent(FetchRequestAdapter.eventResponseHandlerInvokedKey);
                        return await responseHandler.handleResponseAsync(response, errorMappings);
                    }
                    else {
                        try {
                            await this.throwIfFailedResponse(response, errorMappings, span);
                            if (this.shouldReturnUndefined(response))
                                return undefined;
                            const rootNode = await this.getRootParseNode(response);
                            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getObjectValue", (deserializeSpan) => {
                                try {
                                    span.setAttribute(FetchRequestAdapter.responseTypeAttributeKey, "object");
                                    const result = rootNode.getObjectValue(deserializer);
                                    return result;
                                }
                                finally {
                                    deserializeSpan.end();
                                }
                            });
                        }
                        finally {
                            await this.purgeResponseBody(response);
                        }
                    }
                }
                finally {
                    span.end();
                }
            });
        };
        this.sendPrimitiveAsync = (requestInfo, responseType, errorMappings) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            return this.startTracingSpan(requestInfo, "sendPrimitiveAsync", async (span) => {
                try {
                    const response = await this.getHttpResponseMessage(requestInfo, span);
                    const responseHandler = this.getResponseHandler(requestInfo);
                    if (responseHandler) {
                        span.addEvent(FetchRequestAdapter.eventResponseHandlerInvokedKey);
                        return await responseHandler.handleResponseAsync(response, errorMappings);
                    }
                    else {
                        try {
                            await this.throwIfFailedResponse(response, errorMappings, span);
                            if (this.shouldReturnUndefined(response))
                                return undefined;
                            switch (responseType) {
                                case "ArrayBuffer":
                                    // eslint-disable-next-line no-case-declarations
                                    if (!response.body) {
                                        return undefined;
                                    }
                                    return (await response.arrayBuffer());
                                case "string":
                                case "number":
                                case "boolean":
                                case "Date":
                                    // eslint-disable-next-line no-case-declarations
                                    const rootNode = await this.getRootParseNode(response);
                                    span.setAttribute(FetchRequestAdapter.responseTypeAttributeKey, responseType);
                                    return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan(`get${responseType}Value`, (deserializeSpan) => {
                                        try {
                                            if (responseType === "string") {
                                                return rootNode.getStringValue();
                                            }
                                            else if (responseType === "number") {
                                                return rootNode.getNumberValue();
                                            }
                                            else if (responseType === "boolean") {
                                                return rootNode.getBooleanValue();
                                            }
                                            else if (responseType === "Date") {
                                                return rootNode.getDateValue();
                                            }
                                            else if (responseType === "Duration") {
                                                return rootNode.getDurationValue();
                                            }
                                            else if (responseType === "DateOnly") {
                                                return rootNode.getDateOnlyValue();
                                            }
                                            else if (responseType === "TimeOnly") {
                                                return rootNode.getTimeOnlyValue();
                                            }
                                            else {
                                                throw new Error("unexpected type to deserialize");
                                            }
                                        }
                                        finally {
                                            deserializeSpan.end();
                                        }
                                    });
                            }
                        }
                        finally {
                            await this.purgeResponseBody(response);
                        }
                    }
                }
                finally {
                    span.end();
                }
            });
        };
        this.sendNoResponseContentAsync = (requestInfo, errorMappings) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            return this.startTracingSpan(requestInfo, "sendNoResponseContentAsync", async (span) => {
                try {
                    const response = await this.getHttpResponseMessage(requestInfo, span);
                    const responseHandler = this.getResponseHandler(requestInfo);
                    if (responseHandler) {
                        span.addEvent(FetchRequestAdapter.eventResponseHandlerInvokedKey);
                        return await responseHandler.handleResponseAsync(response, errorMappings);
                    }
                    try {
                        await this.throwIfFailedResponse(response, errorMappings, span);
                    }
                    finally {
                        await this.purgeResponseBody(response);
                    }
                }
                finally {
                    span.end();
                }
            });
        };
        this.enableBackingStore = (backingStoreFactory) => {
            this.parseNodeFactory = enableBackingStoreForParseNodeFactory(this.parseNodeFactory);
            this.serializationWriterFactory = enableBackingStoreForSerializationWriterFactory(this.serializationWriterFactory);
            if (!this.serializationWriterFactory || !this.parseNodeFactory)
                throw new Error("unable to enable backing store");
            if (backingStoreFactory) {
                BackingStoreFactorySingleton.instance = backingStoreFactory;
            }
        };
        this.getRootParseNode = (response) => {
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getRootParseNode", async (span) => {
                try {
                    const payload = await response.arrayBuffer();
                    const responseContentType = this.getResponseContentType(response);
                    if (!responseContentType)
                        throw new Error("no response content type found for deserialization");
                    return this.parseNodeFactory.getRootParseNode(responseContentType, payload);
                }
                finally {
                    span.end();
                }
            });
        };
        this.shouldReturnUndefined = (response) => {
            return response.status === 204 || !response.body;
        };
        /** purges the response body if it hasn't been read to release the connection to the server */
        this.purgeResponseBody = async (response) => {
            if (!response.bodyUsed && response.body) {
                await response.arrayBuffer();
            }
        };
        this.throwIfFailedResponse = (response, errorMappings, spanForAttributes) => {
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("throwIfFailedResponse", async (span) => {
                var _a, _b;
                try {
                    if (response.ok)
                        return;
                    spanForAttributes.setStatus({
                        code: SpanStatusCode.ERROR,
                        message: "received_error_response",
                    });
                    const statusCode = response.status;
                    const responseHeaders = {};
                    response.headers.forEach((value, key) => {
                        responseHeaders[key] = value.split(",");
                    });
                    if (!errorMappings || (!errorMappings[statusCode] && !(statusCode >= 400 && statusCode < 500 && errorMappings._4XX) && !(statusCode >= 500 && statusCode < 600 && errorMappings._5XX))) {
                        spanForAttributes.setAttribute(FetchRequestAdapter.errorMappingFoundAttributeName, false);
                        const error = new DefaultApiError("the server returned an unexpected status code and no error class is registered for this code " + statusCode);
                        error.responseStatusCode = statusCode;
                        error.responseHeaders = responseHeaders;
                        spanForAttributes.recordException(error);
                        throw error;
                    }
                    spanForAttributes.setAttribute(FetchRequestAdapter.errorMappingFoundAttributeName, true);
                    const factory = (_b = (_a = errorMappings[statusCode]) !== null && _a !== void 0 ? _a : (statusCode >= 400 && statusCode < 500 ? errorMappings._4XX : undefined)) !== null && _b !== void 0 ? _b : (statusCode >= 500 && statusCode < 600 ? errorMappings._5XX : undefined);
                    const rootNode = await this.getRootParseNode(response);
                    let error = trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getObjectValue", (deserializeSpan) => {
                        try {
                            return rootNode.getObjectValue(factory);
                        }
                        finally {
                            deserializeSpan.end();
                        }
                    });
                    spanForAttributes.setAttribute(FetchRequestAdapter.errorBodyFoundAttributeName, !!error);
                    if (!error)
                        error = new DefaultApiError("unexpected error type" + typeof error);
                    const errorObject = error;
                    errorObject.responseStatusCode = statusCode;
                    errorObject.responseHeaders = responseHeaders;
                    spanForAttributes.recordException(errorObject);
                    throw errorObject;
                }
                finally {
                    span.end();
                }
            });
        };
        this.getHttpResponseMessage = (requestInfo, spanForAttributes, claims) => {
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getHttpResponseMessage", async (span) => {
                try {
                    if (!requestInfo) {
                        throw new Error("requestInfo cannot be null");
                    }
                    this.setBaseUrlForRequestInformation(requestInfo);
                    const additionalContext = {};
                    if (claims) {
                        additionalContext["claims"] = claims;
                    }
                    await this.authenticationProvider.authenticateRequest(requestInfo, additionalContext);
                    const request = await this.getRequestFromRequestInformation(requestInfo, spanForAttributes);
                    if (this.observabilityOptions) {
                        requestInfo.addRequestOptions([this.observabilityOptions]);
                    }
                    let response = await this.httpClient.executeFetch(requestInfo.URL, request, requestInfo.getRequestOptions());
                    response = await this.retryCAEResponseIfRequired(requestInfo, response, spanForAttributes, claims);
                    if (response) {
                        const responseContentLength = response.headers.get("Content-Length");
                        if (responseContentLength) {
                            spanForAttributes.setAttribute("http.response_content_length", parseInt(responseContentLength));
                        }
                        const responseContentType = response.headers.get("Content-Type");
                        if (responseContentType) {
                            spanForAttributes.setAttribute("http.response_content_type", responseContentType);
                        }
                        spanForAttributes.setAttribute("http.status_code", response.status);
                        // getting the http.flavor (protocol version) is impossible with fetch API
                    }
                    return response;
                }
                finally {
                    span.end();
                }
            });
        };
        this.retryCAEResponseIfRequired = async (requestInfo, response, spanForAttributes, claims) => {
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("retryCAEResponseIfRequired", async (span) => {
                try {
                    const responseClaims = this.getClaimsFromResponse(response, claims);
                    if (responseClaims) {
                        span.addEvent(FetchRequestAdapter.authenticateChallengedEventKey);
                        spanForAttributes.setAttribute("http.retry_count", 1);
                        await this.purgeResponseBody(response);
                        return await this.getHttpResponseMessage(requestInfo, spanForAttributes, responseClaims);
                    }
                    return response;
                }
                finally {
                    span.end();
                }
            });
        };
        this.getClaimsFromResponse = (response, claims) => {
            if (response.status === 401 && !claims) {
                // avoid infinite loop, we only retry once
                // no need to check for the content since it's an array and it doesn't need to be rewound
                const rawAuthenticateHeader = response.headers.get("WWW-Authenticate");
                if (rawAuthenticateHeader && /^Bearer /gi.test(rawAuthenticateHeader)) {
                    const rawParameters = rawAuthenticateHeader.replace(/^Bearer /gi, "").split(",");
                    for (const rawParameter of rawParameters) {
                        const trimmedParameter = rawParameter.trim();
                        if (/claims="[^"]+"/gi.test(trimmedParameter)) {
                            return trimmedParameter.replace(/claims="([^"]+)"/gi, "$1");
                        }
                    }
                }
            }
            return undefined;
        };
        this.setBaseUrlForRequestInformation = (requestInfo) => {
            requestInfo.pathParameters["baseurl"] = this.baseUrl;
        };
        this.getRequestFromRequestInformation = (requestInfo, spanForAttributes) => {
            return trace.getTracer(this.observabilityOptions.getTracerInstrumentationName()).startActiveSpan("getRequestFromRequestInformation", async (span) => {
                var _a;
                try {
                    const method = (_a = requestInfo.httpMethod) === null || _a === void 0 ? void 0 : _a.toString();
                    const uri = requestInfo.URL;
                    spanForAttributes.setAttribute("http.method", method !== null && method !== void 0 ? method : "");
                    const uriContainsScheme = uri.indexOf("://") > -1;
                    const schemeSplatUri = uri.split("://");
                    if (uriContainsScheme) {
                        spanForAttributes.setAttribute("http.scheme", schemeSplatUri[0]);
                    }
                    const uriWithoutScheme = uriContainsScheme ? schemeSplatUri[1] : uri;
                    spanForAttributes.setAttribute("http.host", uriWithoutScheme.split("/")[0]);
                    if (this.observabilityOptions.includeEUIIAttributes) {
                        spanForAttributes.setAttribute("http.uri", decodeURIComponent(uri));
                    }
                    const requestContentLength = requestInfo.headers.tryGetValue("Content-Length");
                    if (requestContentLength) {
                        spanForAttributes.setAttribute("http.request_content_length", parseInt(requestContentLength[0]));
                    }
                    const requestContentType = requestInfo.headers.tryGetValue("Content-Type");
                    if (requestContentType) {
                        spanForAttributes.setAttribute("http.request_content_type", requestContentType);
                    }
                    const headers = requestInfo.headers ? Array.from(requestInfo.headers.keys()).map((key) => [key.toString().toLocaleLowerCase(), this.foldHeaderValue(requestInfo.headers.tryGetValue(key))]) : undefined;
                    const request = {
                        method,
                        headers,
                        body: requestInfo.content,
                    };
                    return request;
                }
                finally {
                    span.end();
                }
            });
        };
        this.foldHeaderValue = (value) => {
            if (!value || value.length < 1) {
                return "";
            }
            else if (value.length === 1) {
                return value[0];
            }
            else {
                return value.reduce((acc, val) => acc + val, ",");
            }
        };
        /**
         * @inheritdoc
         */
        this.convertToNativeRequestAsync = async (requestInfo) => {
            if (!requestInfo) {
                throw new Error("requestInfo cannot be null");
            }
            await this.authenticationProvider.authenticateRequest(requestInfo, undefined);
            return this.startTracingSpan(requestInfo, "convertToNativeRequestAsync", async (span) => {
                const request = await this.getRequestFromRequestInformation(requestInfo, span);
                return request;
            });
        };
        if (!authenticationProvider) {
            throw new Error("authentication provider cannot be null");
        }
        if (!parseNodeFactory) {
            throw new Error("parse node factory cannot be null");
        }
        if (!serializationWriterFactory) {
            throw new Error("serialization writer factory cannot be null");
        }
        if (!httpClient) {
            throw new Error("http client cannot be null");
        }
        if (!observabilityOptions) {
            throw new Error("observability options cannot be null");
        }
        else {
            this.observabilityOptions = new ObservabilityOptionsImpl(observabilityOptions);
        }
    }
}
FetchRequestAdapter.responseTypeAttributeKey = "com.microsoft.kiota.response.type";
FetchRequestAdapter.eventResponseHandlerInvokedKey = "com.microsoft.kiota.response_handler_invoked";
FetchRequestAdapter.errorMappingFoundAttributeName = "com.microsoft.kiota.error.mapping_found";
FetchRequestAdapter.errorBodyFoundAttributeName = "com.microsoft.kiota.error.body_found";
FetchRequestAdapter.authenticateChallengedEventKey = "com.microsoft.kiota.authenticate_challenge_received";
