/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * @module RetryHandler
 */
import { HttpMethod } from "@microsoft/kiota-abstractions";
import { trace } from "@opentelemetry/api";
import { getObservabilityOptionsFromRequest } from "../observabilityOptions";
import { getRequestHeader, setRequestHeader } from "../utils/headersUtil";
import { RetryHandlerOptionKey, RetryHandlerOptions } from "./options/retryHandlerOptions";
/**
 * @class
 * @implements Middleware
 * Class for RetryHandler
 */
export class RetryHandler {
    /**
     * @public
     * @constructor
     * To create an instance of RetryHandler
     * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value
     * @returns An instance of RetryHandler
     */
    constructor(options = new RetryHandlerOptions()) {
        this.options = options;
        if (!options) {
            throw new Error("The options parameter is required.");
        }
    }
    /**
     *
     * @private
     * To check whether the response has the retry status code
     * @param {Response} response - The response object
     * @returns Whether the response has retry status code or not
     */
    isRetry(response) {
        return RetryHandler.RETRY_STATUS_CODES.has(response.status);
    }
    /**
     * @private
     * To check whether the payload is buffered or not
     * @param {RequestInit} options - The options of a request
     * @returns Whether the payload is buffered or not
     */
    isBuffered(options) {
        var _a;
        const method = options.method;
        const isPutPatchOrPost = method === HttpMethod.PUT || method === HttpMethod.PATCH || method === HttpMethod.POST;
        if (isPutPatchOrPost) {
            const isStream = ((_a = getRequestHeader(options, "content-type")) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "application/octet-stream";
            if (isStream) {
                return false;
            }
        }
        return true;
    }
    /**
     * @private
     * To get the delay for a retry
     * @param {Response} response - The response object
     * @param {number} retryAttempts - The current attempt count
     * @param {number} delay - The delay value in seconds
     * @returns A delay for a retry
     */
    getDelay(response, retryAttempts, delay) {
        const getRandomness = () => Number(Math.random().toFixed(3));
        const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;
        let newDelay;
        if (retryAfter !== null) {
            // Retry-After: <http-date>
            if (Number.isNaN(Number(retryAfter))) {
                newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);
            }
            else {
                // Retry-After: <delay-seconds>
                newDelay = Number(retryAfter);
            }
        }
        else {
            // Adding randomness to avoid retrying at a same
            newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();
        }
        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());
    }
    /**
     * @private
     * To get an exponential back off value
     * @param {number} attempts - The current attempt count
     * @returns An exponential back off value
     */
    getExponentialBackOffTime(attempts) {
        return Math.round((1 / 2) * (2 ** attempts - 1));
    }
    /**
     * @private
     * @async
     * To add delay for the execution
     * @param {number} delaySeconds - The delay value in seconds
     * @returns Nothing
     */
    async sleep(delaySeconds) {
        const delayMilliseconds = delaySeconds * 1000;
        return new Promise((resolve) => setTimeout(resolve, delayMilliseconds)); // browser or node
    }
    /**
     * @private
     * @async
     * To execute the middleware with retries
     * @param {Context} context - The context object
     * @param {number} retryAttempts - The current attempt count
     * @param {Record<string, RequestOption>} [requestOptions = {}] - The request options
     * @param {RetryHandlerOptions} currentOptions - The retry middleware options instance
     * @param {string} tracerName - The name to use for the tracer
     * @returns A Promise that resolves to nothing
     */
    async executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions, tracerName) {
        var _a;
        const response = await ((_a = this.next) === null || _a === void 0 ? void 0 : _a.execute(url, fetchRequestInit, requestOptions));
        if (!response) {
            throw new Error("Response is undefined");
        }
        if (retryAttempts < currentOptions.maxRetries && this.isRetry(response) && this.isBuffered(fetchRequestInit) && currentOptions.shouldRetry(currentOptions.delay, retryAttempts, url, fetchRequestInit, response)) {
            ++retryAttempts;
            setRequestHeader(fetchRequestInit, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());
            if (response) {
                const delay = this.getDelay(response, retryAttempts, currentOptions.delay);
                await this.sleep(delay);
            }
            if (tracerName) {
                return await trace.getTracer(tracerName).startActiveSpan(`retryHandler - attempt ${retryAttempts}`, (span) => {
                    try {
                        span.setAttribute("http.retry_count", retryAttempts);
                        span.setAttribute("http.status_code", response.status);
                        return this.executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions);
                    }
                    finally {
                        span.end();
                    }
                });
            }
            return await this.executeWithRetry(url, fetchRequestInit, retryAttempts, currentOptions, requestOptions);
        }
        else {
            return response;
        }
    }
    /**
     * @public
     * @async
     * To execute the current middleware
     * @param {Context} context - The context object of the request
     * @returns A Promise that resolves to nothing
     */
    execute(url, requestInit, requestOptions) {
        const retryAttempts = 0;
        let currentOptions = this.options;
        if (requestOptions && requestOptions[RetryHandlerOptionKey]) {
            currentOptions = requestOptions[RetryHandlerOptionKey];
        }
        const obsOptions = getObservabilityOptionsFromRequest(requestOptions);
        if (obsOptions) {
            return trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("retryHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.retry.enable", true);
                    return this.executeWithRetry(url, requestInit, retryAttempts, currentOptions, requestOptions, obsOptions.getTracerInstrumentationName());
                }
                finally {
                    span.end();
                }
            });
        }
        return this.executeWithRetry(url, requestInit, retryAttempts, currentOptions, requestOptions);
    }
}
/**
 * @private
 * @static
 * A list of status codes that needs to be retried
 */
RetryHandler.RETRY_STATUS_CODES = new Set([
    429, // Too many requests
    503, // Service unavailable
    504, // Gateway timeout
]);
/**
 * @private
 * @static
 * A member holding the name of retry attempt header
 */
RetryHandler.RETRY_ATTEMPT_HEADER = "Retry-Attempt";
/**
 * @private
 * @static
 * A member holding the name of retry after header
 */
RetryHandler.RETRY_AFTER_HEADER = "Retry-After";
