/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
import { trace } from "@opentelemetry/api";
import { getObservabilityOptionsFromRequest } from "../observabilityOptions";
import { HeadersInspectionOptions, HeadersInspectionOptionsKey } from "./options/headersInspectionOptions";
/**
 * @class
 * @implements Middleware
 * Inspects the headers of the request and response
 */
export class HeadersInspectionHandler {
    /**
     * @constructor
     * @public
     * Creates new instance of HeadersInspectionHandler
     * @param {HeadersInspectionOptions} _options The options for inspecting the headers
     */
    constructor(_options = new HeadersInspectionOptions()) {
        this._options = _options;
    }
    execute(url, requestInit, requestOptions) {
        let currentOptions = this._options;
        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions[HeadersInspectionOptionsKey]) {
            currentOptions = requestOptions[HeadersInspectionOptionsKey];
        }
        const obsOptions = getObservabilityOptionsFromRequest(requestOptions);
        if (obsOptions) {
            return trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("retryHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.headersInspection.enable", true);
                    return this.executeInternal(url, requestInit, requestOptions, currentOptions);
                }
                finally {
                    span.end();
                }
            });
        }
        return this.executeInternal(url, requestInit, requestOptions, currentOptions);
    }
    async executeInternal(url, requestInit, requestOptions, currentOptions) {
        if (!this.next) {
            throw new Error("next middleware is undefined.");
        }
        if (currentOptions.inspectRequestHeaders && requestInit.headers) {
            for (const [key, value] of requestInit.headers) {
                currentOptions.getRequestHeaders().add(key, value);
            }
        }
        const response = await this.next.execute(url, requestInit, requestOptions);
        if (currentOptions.inspectResponseHeaders && response.headers) {
            for (const [key, value] of response.headers.entries()) {
                currentOptions.getResponseHeaders().add(key, value);
            }
        }
        return response;
    }
}
