"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatSegment = exports.DateOnly = void 0;
/**
 * Represents a date only. ISO 8601.
 */
class DateOnly {
    /**
     * Creates a new DateOnly from the given string.
     * @returns The new DateOnly
     * @throws An error if the year is invalid
     * @throws An error if the month is invalid
     * @throws An error if the day is invalid
     */
    constructor({ year = 0, month = 1, day = 1, }) {
        this.day = day;
        this.month = month;
        this.year = year;
    }
    /**
     * Creates a new DateOnly from the given date.
     * @param date The date
     * @returns The new DateOnly
     * @throws An error if the date is invalid
     */
    static fromDate(date) {
        if (!date) {
            throw new Error("Date cannot be undefined");
        }
        const result = new DateOnly({
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate(),
        });
        return result;
    }
    /**
     * Parses a string into a DateOnly. The string can be of the ISO 8601 time only format or a number representing the ticks of a Date.
     * @param value The value to parse
     * @returns The parsed DateOnly.
     * @throws An error if the value is invalid
     */
    static parse(value) {
        var _a, _b, _c, _d, _e, _f;
        if (!value || value.length === 0) {
            return undefined;
        }
        const exec = /^(?<year>\d{4,})-(?<month>0[1-9]|1[012])-(?<day>0[1-9]|[12]\d|3[01])$/gi.exec(value);
        if (exec) {
            const year = parseInt((_b = (_a = exec.groups) === null || _a === void 0 ? void 0 : _a.year) !== null && _b !== void 0 ? _b : "", 10);
            const month = parseInt((_d = (_c = exec.groups) === null || _c === void 0 ? void 0 : _c.month) !== null && _d !== void 0 ? _d : "", 10);
            const day = parseInt((_f = (_e = exec.groups) === null || _e === void 0 ? void 0 : _e.day) !== null && _f !== void 0 ? _f : "", 10);
            return new DateOnly({ year, month, day });
        }
        const ticks = Date.parse(value);
        if (!isNaN(ticks)) {
            const date = new Date(ticks);
            return this.fromDate(date);
        }
        throw new Error(`Value is not a valid date-only representation: ${value}`);
    }
    /**
     *  Returns a string representation of the date in the format YYYY-MM-DD
     * @returns The date in the format YYYY-MM-DD ISO 8601
     */
    toString() {
        return `${formatSegment(this.year, 4)}-${formatSegment(this.month)}-${formatSegment(this.day)}`;
    }
}
exports.DateOnly = DateOnly;
function formatSegment(segment, digits = 2) {
    return segment.toString().padStart(digits, "0");
}
exports.formatSegment = formatSegment;
//# sourceMappingURL=dateOnly.js.map