"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestInformation = void 0;
const api_1 = require("@opentelemetry/api");
const std_uritemplate_1 = require("@std-uritemplate/std-uritemplate");
const dateOnly_1 = require("./dateOnly");
const duration_1 = require("./duration");
const headers_1 = require("./headers");
const multipartBody_1 = require("./multipartBody");
const recordWithCaseInsensitiveKeys_1 = require("./recordWithCaseInsensitiveKeys");
const timeOnly_1 = require("./timeOnly");
/** This class represents an abstract HTTP request. */
class RequestInformation {
    /**
     * Initializes a request information instance with the provided values.
     * @param httpMethod The HTTP method for the request.
     * @param urlTemplate The URL template for the request.
     * @param pathParameters The path parameters for the request.
     */
    constructor(httpMethod, urlTemplate, pathParameters) {
        /** The path parameters for the request. */
        this.pathParameters = (0, recordWithCaseInsensitiveKeys_1.createRecordWithCaseInsensitiveKeys)();
        /** The Query Parameters of the request. */
        this.queryParameters = (0, recordWithCaseInsensitiveKeys_1.createRecordWithCaseInsensitiveKeys)();
        /** The Request Headers. */
        this.headers = new headers_1.Headers();
        this._requestOptions = (0, recordWithCaseInsensitiveKeys_1.createRecordWithCaseInsensitiveKeys)();
        /**
         * Sets the request body from a model with the specified content type.
         * @param value the models.
         * @param contentType the content type.
         * @param requestAdapter The adapter service to get the serialization writer from.
         * @typeParam T the model type.
         */
        this.setContentFromParsable = (requestAdapter, contentType, value, modelSerializerFunction) => {
            api_1.trace
                .getTracer(RequestInformation.tracerKey)
                .startActiveSpan("setContentFromParsable", (span) => {
                try {
                    const writer = this.getSerializationWriter(requestAdapter, contentType, value);
                    if (value instanceof multipartBody_1.MultipartBody) {
                        contentType += "; boundary=" + value.getBoundary();
                    }
                    if (!this.headers) {
                        this.headers = new headers_1.Headers();
                    }
                    if (Array.isArray(value)) {
                        span.setAttribute(RequestInformation.requestTypeKey, "object[]");
                        writer.writeCollectionOfObjectValues(undefined, value, 
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        modelSerializerFunction);
                    }
                    else {
                        span.setAttribute(RequestInformation.requestTypeKey, "object");
                        writer.writeObjectValue(undefined, value, modelSerializerFunction);
                    }
                    this.setContentAndContentType(writer, contentType);
                }
                finally {
                    span.end();
                }
            });
        };
        this.setContentAndContentType = (writer, contentType) => {
            if (contentType) {
                this.headers.tryAdd(RequestInformation.contentTypeHeader, contentType);
            }
            this.content = writer.getSerializedContent();
        };
        this.getSerializationWriter = (requestAdapter, contentType, ...values) => {
            if (!requestAdapter)
                throw new Error("httpCore cannot be undefined");
            if (!contentType)
                throw new Error("contentType cannot be undefined");
            if (!values || values.length === 0) {
                throw new Error("values cannot be undefined or empty");
            }
            return requestAdapter
                .getSerializationWriterFactory()
                .getSerializationWriter(contentType);
        };
        /**
         * Sets the request body from a model with the specified content type.
         * @param value the scalar values to serialize.
         * @param contentType the content type.
         * @param requestAdapter The adapter service to get the serialization writer from.
         * @typeParam T the model type.
         */
        this.setContentFromScalar = (requestAdapter, contentType, value) => {
            api_1.trace
                .getTracer(RequestInformation.tracerKey)
                .startActiveSpan("setContentFromScalar", (span) => {
                try {
                    const writer = this.getSerializationWriter(requestAdapter, contentType, value);
                    if (!this.headers) {
                        this.headers = new headers_1.Headers();
                    }
                    if (Array.isArray(value)) {
                        span.setAttribute(RequestInformation.requestTypeKey, "[]");
                        writer.writeCollectionOfPrimitiveValues(undefined, value);
                    }
                    else {
                        const valueType = typeof value;
                        span.setAttribute(RequestInformation.requestTypeKey, valueType);
                        if (!value) {
                            writer.writeNullValue(undefined);
                        }
                        else if (valueType === "boolean") {
                            writer.writeBooleanValue(undefined, value);
                        }
                        else if (valueType === "string") {
                            writer.writeStringValue(undefined, value);
                        }
                        else if (value instanceof Date) {
                            writer.writeDateValue(undefined, value);
                        }
                        else if (value instanceof dateOnly_1.DateOnly) {
                            writer.writeDateOnlyValue(undefined, value);
                        }
                        else if (value instanceof timeOnly_1.TimeOnly) {
                            writer.writeTimeOnlyValue(undefined, value);
                        }
                        else if (value instanceof duration_1.Duration) {
                            writer.writeDurationValue(undefined, value);
                        }
                        else if (valueType === "number") {
                            writer.writeNumberValue(undefined, value);
                        }
                        else if (Array.isArray(value)) {
                            writer.writeCollectionOfPrimitiveValues(undefined, value);
                        }
                        else {
                            throw new Error(`encountered unknown value type during serialization ${valueType}`);
                        }
                    }
                    this.setContentAndContentType(writer, contentType);
                }
                finally {
                    span.end();
                }
            });
        };
        /**
         * Sets the request body to be a binary stream.
         * @param value the binary stream
         * @param contentType the content type.
         */
        this.setStreamContent = (value, contentType) => {
            if (!contentType) {
                contentType = RequestInformation.binaryContentType;
            }
            this.headers.tryAdd(RequestInformation.contentTypeHeader, contentType);
            this.content = value;
        };
        if (httpMethod) {
            this.httpMethod = httpMethod;
        }
        if (urlTemplate) {
            this.urlTemplate = urlTemplate;
        }
        if (pathParameters) {
            this.pathParameters = pathParameters;
        }
    }
    /** Gets the URL of the request  */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    get URL() {
        const rawUrl = this.pathParameters[RequestInformation.raw_url_key];
        if (this.uri) {
            return this.uri;
        }
        else if (rawUrl) {
            this.URL = rawUrl;
            return rawUrl;
        }
        else if (!this.queryParameters) {
            throw new Error("queryParameters cannot be undefined");
        }
        else if (!this.pathParameters) {
            throw new Error("pathParameters cannot be undefined");
        }
        else if (!this.urlTemplate) {
            throw new Error("urlTemplate cannot be undefined");
        }
        else {
            const data = {};
            for (const key in this.queryParameters) {
                if (this.queryParameters[key] !== null && this.queryParameters[key] !== undefined) {
                    data[key] = this.queryParameters[key];
                }
            }
            for (const key in this.pathParameters) {
                if (this.pathParameters[key]) {
                    data[key] = this.pathParameters[key];
                }
            }
            return std_uritemplate_1.StdUriTemplate.expand(this.urlTemplate, data);
        }
    }
    /** Sets the URL of the request */
    set URL(url) {
        if (!url)
            throw new Error("URL cannot be undefined");
        this.uri = url;
        this.queryParameters = {};
        this.pathParameters = {};
    }
    /** Gets the request options for the request. */
    getRequestOptions() {
        return this._requestOptions;
    }
    /** Adds the headers for the request. */
    addRequestHeaders(source) {
        if (source) {
            this.headers.addAllRaw(source);
        }
    }
    /** Adds the request options for the request. */
    addRequestOptions(options) {
        if (!options || options.length === 0)
            return;
        options.forEach((option) => {
            this._requestOptions[option.getKey()] = option;
        });
    }
    /** Removes the request options for the request. */
    removeRequestOptions(...options) {
        if (!options || options.length === 0)
            return;
        options.forEach((option) => {
            delete this._requestOptions[option.getKey()];
        });
    }
    /**
     * Sets the query string parameters from a raw object.
     * @param parameters the parameters.
     * @param p the mapping from code symbol to URI template parameter name.
     */
    setQueryStringParametersFromRawObject(q, p) {
        if (q === null || q === undefined)
            return;
        Object.entries(q).forEach(([k, v]) => {
            let key = k;
            if (p) {
                const keyCandidate = p[key];
                if (keyCandidate) {
                    key = keyCandidate;
                }
            }
            this.queryParameters[key] = v;
        });
    }
    /**
     * Configure the current request with headers, query parameters and options.
     * @param config the configuration object to use.
     * @param queryParametersMapper mapping between code symbols and URI template parameter names.
     */
    configure(config, queryParametersMapper) {
        if (!config)
            return;
        this.addRequestHeaders(config.headers);
        this.setQueryStringParametersFromRawObject(config.queryParameters, queryParametersMapper);
        this.addRequestOptions(config.options);
    }
}
exports.RequestInformation = RequestInformation;
RequestInformation.raw_url_key = "request-raw-url";
RequestInformation.binaryContentType = "application/octet-stream";
RequestInformation.contentTypeHeader = "Content-Type";
RequestInformation.tracerKey = "@microsoft/kiota-abstractions";
RequestInformation.requestTypeKey = "com.microsoft.kiota.request.type";
//# sourceMappingURL=requestInformation.js.map