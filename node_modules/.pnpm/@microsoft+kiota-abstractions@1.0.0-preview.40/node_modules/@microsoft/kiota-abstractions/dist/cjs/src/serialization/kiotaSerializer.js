"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeCollection = exports.deserialize = exports.serializeCollectionToString = exports.serializeCollection = exports.serializeToString = exports.serialize = void 0;
const parseNodeFactoryRegistry_1 = require("./parseNodeFactoryRegistry");
const serializationWriterFactoryRegistry_1 = require("./serializationWriterFactoryRegistry");
/**
 * Serializes a parsable object into a buffer
 * @param contentType the content type to serialize to
 * @param value the value to serialize
 * @param serializationFunction the serialization function for the model type
 * @returns a buffer containing the serialized value
 */
function serialize(contentType, value, serializationFunction) {
    const writer = getSerializationWriter(contentType, value, serializationFunction);
    writer.writeObjectValue(undefined, value, serializationFunction);
    return writer.getSerializedContent();
}
exports.serialize = serialize;
/**
 * Serializes a parsable object into a string representation
 * @param contentType the content type to serialize to
 * @param value the value to serialize
 * @param serializationFunction the serialization function for the model type
 * @returns a string representing the serialized value
 */
function serializeToString(contentType, value, serializationFunction) {
    const buffer = serialize(contentType, value, serializationFunction);
    return getStringValueFromBuffer(buffer);
}
exports.serializeToString = serializeToString;
/**
 * Serializes a collection of parsable objects into a buffer
 * @param contentType the content type to serialize to
 * @param value the value to serialize
 * @param serializationFunction the serialization function for the model type
 * @returns a string representing the serialized value
 */
function serializeCollection(contentType, values, serializationFunction) {
    const writer = getSerializationWriter(contentType, values, serializationFunction);
    writer.writeCollectionOfObjectValues(undefined, values, serializationFunction);
    return writer.getSerializedContent();
}
exports.serializeCollection = serializeCollection;
/**
 * Serializes a collection of parsable objects into a string representation
 * @param contentType the content type to serialize to
 * @param value the value to serialize
 * @param serializationFunction the serialization function for the model type
 * @returns a string representing the serialized value
 */
function serializeCollectionToString(contentType, values, serializationFunction) {
    const buffer = serializeCollection(contentType, values, serializationFunction);
    return getStringValueFromBuffer(buffer);
}
exports.serializeCollectionToString = serializeCollectionToString;
function getSerializationWriter(contentType, value, serializationFunction) {
    if (!contentType) {
        throw new Error("content type cannot be undefined or empty");
    }
    if (!value) {
        throw new Error("value cannot be undefined");
    }
    if (!serializationFunction) {
        throw new Error("serializationFunction cannot be undefined");
    }
    return serializationWriterFactoryRegistry_1.SerializationWriterFactoryRegistry.defaultInstance.getSerializationWriter(contentType);
}
function getStringValueFromBuffer(buffer) {
    const decoder = new TextDecoder();
    return decoder.decode(buffer);
}
/**
 * Deserializes a buffer into a parsable object
 * @param contentType the content type to serialize to
 * @param bufferOrString the value to serialize
 * @param factory the factory for the model type
 * @returns the deserialized parsable object
 */
function deserialize(contentType, bufferOrString, factory) {
    if (typeof bufferOrString === "string") {
        bufferOrString = getBufferFromString(bufferOrString);
    }
    const reader = getParseNode(contentType, bufferOrString, factory);
    return reader.getObjectValue(factory);
}
exports.deserialize = deserialize;
function getParseNode(contentType, buffer, factory) {
    if (!contentType) {
        throw new Error("content type cannot be undefined or empty");
    }
    if (!buffer) {
        throw new Error("buffer cannot be undefined");
    }
    if (!factory) {
        throw new Error("factory cannot be undefined");
    }
    return parseNodeFactoryRegistry_1.ParseNodeFactoryRegistry.defaultInstance.getRootParseNode(contentType, buffer);
}
/**
 * Deserializes a buffer into a a collection of parsable object
 * @param contentType the content type to serialize to
 * @param bufferOrString the value to serialize
 * @param factory the factory for the model type
 * @returns the deserialized collection of parsable objects
 */
function deserializeCollection(contentType, bufferOrString, factory) {
    if (typeof bufferOrString === "string") {
        bufferOrString = getBufferFromString(bufferOrString);
    }
    const reader = getParseNode(contentType, bufferOrString, factory);
    return reader.getCollectionOfObjectValues(factory);
}
exports.deserializeCollection = deserializeCollection;
function getBufferFromString(value) {
    const encoder = new TextEncoder();
    return encoder.encode(value).buffer;
}
//# sourceMappingURL=kiotaSerializer.js.map