"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableBackingStoreForParseNodeFactory = exports.enableBackingStoreForSerializationWriterFactory = exports.registerDefaultDeserializer = exports.registerDefaultSerializer = void 0;
const serialization_1 = require("./serialization");
const store_1 = require("./store");
/**
 * Registers the default serializer to the registry.
 * @param type the class of the factory to be registered.
 */
function registerDefaultSerializer(type) {
    if (!type)
        throw new Error("Type is required");
    const serializer = new type();
    serialization_1.SerializationWriterFactoryRegistry.defaultInstance.contentTypeAssociatedFactories.set(serializer.getValidContentType(), serializer);
}
exports.registerDefaultSerializer = registerDefaultSerializer;
/**
 * Registers the default deserializer to the registry.
 * @param type the class of the factory to be registered.
 */
function registerDefaultDeserializer(type) {
    if (!type)
        throw new Error("Type is required");
    const deserializer = new type();
    serialization_1.ParseNodeFactoryRegistry.defaultInstance.contentTypeAssociatedFactories.set(deserializer.getValidContentType(), deserializer);
}
exports.registerDefaultDeserializer = registerDefaultDeserializer;
/**
 * Enables the backing store on default serialization writers and the given serialization writer.
 * @param original The serialization writer to enable the backing store on.
 * @return A new serialization writer with the backing store enabled.
 */
function enableBackingStoreForSerializationWriterFactory(original) {
    if (!original)
        throw new Error("Original must be specified");
    let result = original;
    if (original instanceof serialization_1.SerializationWriterFactoryRegistry) {
        enableBackingStoreForSerializationRegistry(original);
    }
    else {
        result = new store_1.BackingStoreSerializationWriterProxyFactory(original);
    }
    enableBackingStoreForSerializationRegistry(serialization_1.SerializationWriterFactoryRegistry.defaultInstance);
    enableBackingStoreForParseNodeRegistry(serialization_1.ParseNodeFactoryRegistry.defaultInstance);
    return result;
}
exports.enableBackingStoreForSerializationWriterFactory = enableBackingStoreForSerializationWriterFactory;
/**
 * Enables the backing store on default parse node factories and the given parse node factory.
 * @param original The parse node factory to enable the backing store on.
 * @return A new parse node factory with the backing store enabled.
 */
function enableBackingStoreForParseNodeFactory(original) {
    if (!original)
        throw new Error("Original must be specified");
    let result = original;
    if (original instanceof serialization_1.ParseNodeFactoryRegistry) {
        enableBackingStoreForParseNodeRegistry(original);
    }
    else {
        result = new store_1.BackingStoreParseNodeFactory(original);
    }
    enableBackingStoreForParseNodeRegistry(serialization_1.ParseNodeFactoryRegistry.defaultInstance);
    return result;
}
exports.enableBackingStoreForParseNodeFactory = enableBackingStoreForParseNodeFactory;
function enableBackingStoreForParseNodeRegistry(registry) {
    for (const [k, v] of registry.contentTypeAssociatedFactories) {
        if (!(v instanceof store_1.BackingStoreParseNodeFactory ||
            v instanceof serialization_1.ParseNodeFactoryRegistry)) {
            registry.contentTypeAssociatedFactories.set(k, new store_1.BackingStoreParseNodeFactory(v));
        }
    }
}
function enableBackingStoreForSerializationRegistry(registry) {
    for (const [k, v] of registry.contentTypeAssociatedFactories) {
        if (!(v instanceof store_1.BackingStoreSerializationWriterProxyFactory ||
            v instanceof serialization_1.SerializationWriterFactoryRegistry)) {
            registry.contentTypeAssociatedFactories.set(k, new store_1.BackingStoreSerializationWriterProxyFactory(v));
        }
    }
}
//# sourceMappingURL=apiClientBuilder.js.map