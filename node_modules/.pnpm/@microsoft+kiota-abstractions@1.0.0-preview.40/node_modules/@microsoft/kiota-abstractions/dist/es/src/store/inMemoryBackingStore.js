import { v4 as uuidv4 } from "uuid";
/** In-memory implementation of the backing store. Allows for dirty tracking of changes. */
export class InMemoryBackingStore {
    constructor() {
        this.subscriptions = new Map();
        this.store = new Map();
        this.returnOnlyChangedValues = false;
        this._initializationCompleted = true;
    }
    get(key) {
        const wrapper = this.store.get(key);
        if (wrapper &&
            ((this.returnOnlyChangedValues && wrapper.changed) ||
                !this.returnOnlyChangedValues)) {
            return wrapper.value;
        }
        return undefined;
    }
    set(key, value) {
        const oldValueWrapper = this.store.get(key);
        const oldValue = oldValueWrapper === null || oldValueWrapper === void 0 ? void 0 : oldValueWrapper.value;
        if (oldValueWrapper) {
            oldValueWrapper.value = value;
            oldValueWrapper.changed = this.initializationCompleted;
        }
        else {
            this.store.set(key, {
                changed: this.initializationCompleted,
                value,
            });
        }
        this.subscriptions.forEach((sub) => {
            sub(key, oldValue, value);
        });
    }
    enumerate() {
        let filterableArray = [...this.store.entries()];
        if (this.returnOnlyChangedValues) {
            filterableArray = filterableArray.filter(([_, v]) => v.changed);
        }
        return filterableArray.map(([key, value]) => {
            return { key, value };
        });
    }
    enumerateKeysForValuesChangedToNull() {
        const keys = [];
        for (const [key, entry] of this.store) {
            if (entry.changed && !entry.value) {
                keys.push(key);
            }
        }
        return keys;
    }
    subscribe(callback, subscriptionId) {
        if (!callback) {
            throw new Error("callback cannot be undefined");
        }
        subscriptionId = subscriptionId !== null && subscriptionId !== void 0 ? subscriptionId : uuidv4();
        this.subscriptions.set(subscriptionId, callback);
        return subscriptionId;
    }
    unsubscribe(subscriptionId) {
        this.subscriptions.delete(subscriptionId);
    }
    clear() {
        this.store.clear();
    }
    set initializationCompleted(value) {
        this._initializationCompleted = value;
        this.store.forEach((v) => {
            v.changed = !value;
        });
    }
    get initializationCompleted() {
        return this._initializationCompleted;
    }
}
//# sourceMappingURL=inMemoryBackingStore.js.map