import { getPathParameters } from "./getPathParameters";
import { HttpMethod } from "./httpMethod";
import { RequestInformation, } from "./requestInformation";
function sanitizeMethodName(methodName) {
    if (methodName.startsWith("to")) {
        return methodName
            .substring(2)
            .replace("RequestInformation", "")
            .toLowerCase();
    }
    return methodName;
}
function getRequestMethod(key) {
    switch (sanitizeMethodName(key)) {
        case "delete":
            return "delete";
        case "get":
            return "get";
        case "head":
            return "head";
        case "options":
            return "options";
        case "patch":
            return "patch";
        case "post":
            return "post";
        case "put":
            return "put";
        default:
            return undefined;
    }
}
function toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, httpMethod, body, bodyMediaType, requestConfiguration) {
    const requestInfo = new RequestInformation(httpMethod, urlTemplate, pathParameters);
    requestInfo.configure(requestConfiguration, metadata.queryParametersMapper);
    addAcceptHeaderIfPresent(metadata, requestInfo);
    if (metadata.requestBodySerializer) {
        if (!body)
            throw new Error("body cannot be undefined");
        if (typeof metadata.requestBodySerializer === "function") {
            requestInfo.setContentFromParsable(requestAdapter, metadata.requestBodyContentType
                ? metadata.requestBodyContentType
                : bodyMediaType, body, metadata.requestBodySerializer);
        }
        else {
            requestInfo.setContentFromScalar(requestAdapter, metadata.requestBodyContentType
                ? metadata.requestBodyContentType
                : bodyMediaType, body);
        }
    }
    else if (metadata.requestInformationContentSetMethod === "setStreamContent") {
        if (!body)
            throw new Error("body cannot be undefined");
        requestInfo.setStreamContent(body, metadata.requestBodyContentType
            ? metadata.requestBodyContentType
            : bodyMediaType);
    }
    return requestInfo;
}
function addAcceptHeaderIfPresent(metadata, requestInfo) {
    if (metadata.responseBodyContentType) {
        requestInfo.headers.tryAdd("Accept", metadata.responseBodyContentType);
    }
}
function getRequestMediaTypeUserDefinedValue(requestMetadata, args) {
    if (args.length > 2 &&
        !requestMetadata.requestBodySerializer &&
        requestMetadata.requestInformationContentSetMethod === "setStreamContent") {
        // request body with unknown media type so we have an argument for it.
        return args[1];
    }
    return undefined;
}
function getRequestConfigurationValue(args) {
    if (args.length > 0) {
        // request configuration is always the last argument
        return args[args.length - 1];
    }
    return undefined;
}
function sendAsync(requestAdapter, requestInfo, metadata) {
    switch (metadata.adapterMethodName) {
        case "sendAsync":
            if (!metadata.responseBodyFactory) {
                throw new Error("couldn't find response body factory");
            }
            return requestAdapter.sendAsync(requestInfo, metadata.responseBodyFactory, metadata.errorMappings);
        case "sendCollectionAsync":
            if (!metadata.responseBodyFactory) {
                throw new Error("couldn't find response body factory");
            }
            return requestAdapter.sendCollectionAsync(requestInfo, metadata.responseBodyFactory, metadata.errorMappings);
        case "sendCollectionOfPrimitiveAsync":
            if (!metadata.responseBodyFactory) {
                throw new Error("couldn't find response body factory");
            }
            return requestAdapter.sendCollectionOfPrimitiveAsync(requestInfo, metadata.responseBodyFactory, metadata.errorMappings);
        case "sendPrimitiveAsync":
            if (!metadata.responseBodyFactory) {
                throw new Error("couldn't find response body factory");
            }
            return requestAdapter.sendPrimitiveAsync(requestInfo, metadata.responseBodyFactory, metadata.errorMappings);
        case "sendNoResponseContentAsync":
            return requestAdapter.sendNoResponseContentAsync(requestInfo, metadata.errorMappings);
        default:
            throw new Error("couldn't find adapter method");
    }
}
export function apiClientProxifier(requestAdapter, pathParameters, urlTemplate, navigationMetadata, requestsMetadata) {
    if (!requestAdapter)
        throw new Error("requestAdapter cannot be undefined");
    if (!pathParameters)
        throw new Error("pathParameters cannot be undefined");
    if (!urlTemplate)
        throw new Error("urlTemplate cannot be undefined");
    return new Proxy({}, {
        get(target, property) {
            const name = String(property);
            if (name === "withUrl") {
                return (rawUrl) => {
                    if (!rawUrl)
                        throw new Error("rawUrl cannot be undefined");
                    return apiClientProxifier(requestAdapter, getPathParameters(rawUrl), urlTemplate, navigationMetadata, requestsMetadata);
                };
            }
            if (requestsMetadata) {
                const metadataKey = getRequestMethod(name);
                if (metadataKey) {
                    const metadata = requestsMetadata[metadataKey];
                    if (metadata) {
                        switch (name) {
                            case "get":
                                return (requestConfiguration) => {
                                    const requestInfo = toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.GET, undefined, undefined, requestConfiguration);
                                    return sendAsync(requestAdapter, requestInfo, metadata);
                                };
                            case "patch":
                                return (...args) => {
                                    const requestInfo = toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.PATCH, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                    return sendAsync(requestAdapter, requestInfo, metadata);
                                };
                            case "put":
                                return (...args) => {
                                    const requestInfo = toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.PUT, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                    return sendAsync(requestAdapter, requestInfo, metadata);
                                };
                            case "delete":
                                return (...args) => {
                                    const requestInfo = toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.DELETE, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                    return sendAsync(requestAdapter, requestInfo, metadata);
                                };
                            case "post":
                                return (...args) => {
                                    const requestInfo = toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.POST, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                    return sendAsync(requestAdapter, requestInfo, metadata);
                                };
                            case "toGetRequestInformation":
                                return (requestConfiguration) => {
                                    return toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.GET, undefined, undefined, requestConfiguration);
                                };
                            case "toPatchRequestInformation":
                                return (...args) => {
                                    return toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.PATCH, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                };
                            case "toPutRequestInformation":
                                return (...args) => {
                                    return toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.PUT, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                };
                            case "toDeleteRequestInformation":
                                return (...args) => {
                                    return toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.DELETE, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                };
                            case "toPostRequestInformation":
                                return (...args) => {
                                    return toRequestInformation(urlTemplate, pathParameters, metadata, requestAdapter, HttpMethod.POST, args.length > 0 ? args[0] : undefined, getRequestMediaTypeUserDefinedValue(metadata, args), getRequestConfigurationValue(args));
                                };
                            default:
                                break;
                        }
                    }
                }
            }
            if (navigationMetadata) {
                const navigationCandidate = navigationMetadata[name];
                if (navigationCandidate) {
                    if (!navigationCandidate.pathParametersMappings ||
                        navigationCandidate.pathParametersMappings.length === 0) {
                        // navigation property
                        return apiClientProxifier(requestAdapter, getPathParameters(pathParameters), navigationCandidate.uriTemplate, navigationCandidate.navigationMetadata, navigationCandidate.requestsMetadata);
                    }
                    return (...argArray) => {
                        // navigation method like indexers or multiple path parameters
                        const downWardPathParameters = getPathParameters(pathParameters);
                        if (navigationCandidate.pathParametersMappings &&
                            navigationCandidate.pathParametersMappings.length > 0) {
                            for (let i = 0; i < argArray.length; i++) {
                                const element = argArray[i];
                                downWardPathParameters[navigationCandidate.pathParametersMappings[i]] = element;
                            }
                        }
                        return apiClientProxifier(requestAdapter, downWardPathParameters, navigationCandidate.uriTemplate, navigationCandidate.navigationMetadata, navigationCandidate.requestsMetadata);
                    };
                }
                throw new Error(`couldn't find navigation property ${name} data: ${JSON.stringify(navigationMetadata)}`);
            }
        },
    });
}
//# sourceMappingURL=apiClientProxifier.js.map