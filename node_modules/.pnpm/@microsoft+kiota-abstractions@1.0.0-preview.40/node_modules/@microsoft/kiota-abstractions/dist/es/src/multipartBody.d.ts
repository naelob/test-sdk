import type { RequestAdapter } from "./requestAdapter";
import type { ModelSerializerFunction, Parsable, ParseNode, SerializationWriter } from "./serialization";
/**
 * Defines an interface for a multipart body for request or response.
 */
export declare class MultipartBody implements Parsable {
    private readonly _boundary;
    private readonly _parts;
    requestAdapter?: RequestAdapter;
    /**
     * Instantiates a new MultipartBody.
     */
    constructor();
    /**
     * Adds or replaces a part with the given name, content type and content.
     * @param partName the name of the part to add or replace.
     * @param partContentType the content type of the part to add or replace.
     * @param content the content of the part to add or replace.
     * @param serializationCallback the serialization callback to use when serializing the part.
     */
    addOrReplacePart<T>(partName: string, partContentType: string, content: T, serializationCallback?: ModelSerializerFunction<Parsable>): void;
    /**
     * Gets the content of the part with the given name.
     * @param partName the name of the part to get the content for.
     * @returns the content of the part with the given name.
     */
    getPartValue<T>(partName: string): T | undefined;
    /**
     * Removes the part with the given name.
     * @param partName the name of the part to remove.
     * @returns true if the part was removed, false if it did not exist.
     */
    removePart(partName: string): boolean;
    /**
     * Gets the boundary used to separate each part.
     * @returns the boundary value.
     */
    getBoundary(): string;
    private normalizePartName;
    /**
     * Lists all the parts in the multipart body.
     * WARNING: meant for internal use only
     * @returns the list of parts in the multipart body.
     */
    listParts(): Record<string, MultipartEntry>;
}
interface MultipartEntry {
    contentType: string;
    content: any;
    originalName: string;
    serializationCallback?: ModelSerializerFunction<Parsable>;
}
export declare function serializeMultipartBody(writer: SerializationWriter, multipartBody?: Partial<MultipartBody>): void;
export declare function deserializeIntoMultipartBody(_?: Partial<MultipartBody> | undefined): Record<string, (node: ParseNode) => void>;
export declare function createMessageFromDiscriminatorValue(parseNode: ParseNode | undefined): typeof deserializeIntoMultipartBody;
export {};
//# sourceMappingURL=multipartBody.d.ts.map