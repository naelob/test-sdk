/**
 * This factory holds a list of all the registered factories for the various types of nodes.
 */
export class ParseNodeFactoryRegistry {
    constructor() {
        /** List of factories that are registered by content type. */
        this.contentTypeAssociatedFactories = new Map();
    }
    getValidContentType() {
        throw new Error("The registry supports multiple content types. Get the registered factory instead.");
    }
    getRootParseNode(contentType, content) {
        if (!contentType) {
            throw new Error("content type cannot be undefined or empty");
        }
        if (!content) {
            throw new Error("content cannot be undefined or empty");
        }
        const vendorSpecificContentType = contentType.split(";")[0];
        let factory = this.contentTypeAssociatedFactories.get(vendorSpecificContentType);
        if (factory) {
            return factory.getRootParseNode(vendorSpecificContentType, content);
        }
        const cleanedContentType = vendorSpecificContentType.replace(/[^/]+\+/gi, "");
        factory = this.contentTypeAssociatedFactories.get(cleanedContentType);
        if (factory) {
            return factory.getRootParseNode(cleanedContentType, content);
        }
        throw new Error(`Content type ${cleanedContentType} does not have a factory registered to be parsed`);
    }
}
/** Default singleton instance of the registry to be used when registring new factories that should be available by default. */
ParseNodeFactoryRegistry.defaultInstance = new ParseNodeFactoryRegistry();
//# sourceMappingURL=parseNodeFactoryRegistry.js.map