import { createBackedModelProxyHandler, DateOnly, Duration, parseGuidString, TimeOnly, isBackingStoreEnabled, toFirstCharacterUpper, } from "@microsoft/kiota-abstractions";
export class FormParseNode {
    /**
     *
     */
    constructor(_rawString) {
        this._rawString = _rawString;
        this._fields = {};
        this.normalizeKey = (key) => decodeURIComponent(key).trim();
        this.getStringValue = () => decodeURIComponent(this._rawString);
        this.getChildNode = (identifier) => {
            if (this._fields[identifier]) {
                return new FormParseNode(this._fields[identifier]);
            }
            return undefined;
        };
        this.getBooleanValue = () => {
            var _a;
            const value = (_a = this.getStringValue()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (value === "true" || value === "1") {
                return true;
            }
            else if (value === "false" || value === "0") {
                return false;
            }
            return undefined;
        };
        this.getNumberValue = () => parseFloat(this.getStringValue());
        this.getGuidValue = () => parseGuidString(this.getStringValue());
        this.getDateValue = () => new Date(Date.parse(this.getStringValue()));
        this.getDateOnlyValue = () => DateOnly.parse(this.getStringValue());
        this.getTimeOnlyValue = () => TimeOnly.parse(this.getStringValue());
        this.getDurationValue = () => Duration.parse(this.getStringValue());
        this.getCollectionOfPrimitiveValues = () => {
            return this._rawString.split(",").map((x) => {
                const currentParseNode = new FormParseNode(x);
                const typeOfX = typeof x;
                if (typeOfX === "boolean") {
                    return currentParseNode.getBooleanValue();
                }
                else if (typeOfX === "string") {
                    return currentParseNode.getStringValue();
                }
                else if (typeOfX === "number") {
                    return currentParseNode.getNumberValue();
                }
                else if (x instanceof Date) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof DateOnly) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof TimeOnly) {
                    return currentParseNode.getDateValue();
                }
                else if (x instanceof Duration) {
                    return currentParseNode.getDateValue();
                }
                else {
                    throw new Error(`encountered an unknown type during deserialization ${typeof x}`);
                }
            });
        };
        this.getCollectionOfObjectValues = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        parsableFactory) => {
            throw new Error(`serialization of collections is not supported with URI encoding`);
        };
        this.getObjectValue = (parsableFactory) => {
            const temp = {};
            const enableBackingStore = isBackingStoreEnabled(parsableFactory(this)(temp));
            const value = enableBackingStore ? new Proxy(temp, createBackedModelProxyHandler()) : temp;
            if (this.onBeforeAssignFieldValues) {
                this.onBeforeAssignFieldValues(value);
            }
            this.assignFieldValues(value, parsableFactory);
            if (this.onAfterAssignFieldValues) {
                this.onAfterAssignFieldValues(value);
            }
            return value;
        };
        this.getCollectionOfEnumValues = (type) => {
            const rawValues = this.getStringValue();
            if (!rawValues) {
                return [];
            }
            return rawValues.split(",").map((x) => type[toFirstCharacterUpper(x)]);
        };
        this.getEnumValue = (type) => {
            const values = this.getCollectionOfEnumValues(type);
            if (values.length > 0) {
                return values[0];
            }
            else {
                return undefined;
            }
        };
        this.assignFieldValues = (model, parsableFactory) => {
            const fields = parsableFactory(this)(model);
            Object.entries(this._fields)
                .filter((x) => !/^null$/i.test(x[1]))
                .forEach(([k, v]) => {
                const deserializer = fields[k];
                if (deserializer) {
                    deserializer(new FormParseNode(v));
                }
                else {
                    model[k] = v;
                }
            });
        };
        if (!_rawString) {
            throw new Error("rawString cannot be undefined");
        }
        _rawString
            .split("&")
            .map((x) => x.split("="))
            .filter((x) => x.length === 2)
            .forEach((x) => {
            const key = this.normalizeKey(x[0]);
            if (this._fields[key]) {
                this._fields[key] += "," + x[1];
            }
            else {
                this._fields[key] = x[1];
            }
        });
    }
    getByteArrayValue() {
        throw new Error("serialization of byt arrays is not supported with URI encoding");
    }
}
