/* eslint-disable @typescript-eslint/no-unused-expressions */
import { DateOnly, Duration, TimeOnly, } from "@microsoft/kiota-abstractions";
export class FormSerializationWriter {
    constructor() {
        this.writer = [];
        this.depth = -1;
        this.writeStringValue = (key, value) => {
            if (key && value) {
                this.writePropertyName(key);
                this.writer.push(`=${encodeURIComponent(value)}`);
                this.writer.push(FormSerializationWriter.propertySeparator);
            }
        };
        this.writePropertyName = (key) => {
            this.writer.push(encodeURIComponent(key));
        };
        this.writeBooleanValue = (key, value) => {
            value !== null &&
                value !== undefined &&
                this.writeStringValue(key, `${value}`);
        };
        this.writeNumberValue = (key, value) => {
            value && this.writeStringValue(key, `${value}`);
        };
        this.writeGuidValue = (key, value) => {
            value && this.writeStringValue(key, `${value}`);
        };
        this.writeDateValue = (key, value) => {
            value && this.writeStringValue(key, value.toISOString());
        };
        this.writeDateOnlyValue = (key, value) => {
            value && this.writeStringValue(key, value.toString());
        };
        this.writeTimeOnlyValue = (key, value) => {
            value && this.writeStringValue(key, value.toString());
        };
        this.writeDurationValue = (key, value) => {
            value && this.writeStringValue(key, value.toString());
        };
        this.writeNullValue = (key) => {
            this.writeStringValue(key, `null`);
        };
        this.writeCollectionOfPrimitiveValues = (_key, _values) => {
            if (_key && _values) {
                _values.forEach((val) => {
                    this.writeAnyValue(_key, val);
                });
            }
        };
        this.writeCollectionOfObjectValues = (
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _key, 
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        _values) => {
            throw new Error(`serialization of collections is not supported with URI encoding`);
        };
        this.writeObjectValue = (key, value, serializerMethod) => {
            if (++this.depth > 0) {
                throw new Error(`serialization of nested objects is not supported with URI encoding`);
            }
            if (value) {
                if (key) {
                    this.writePropertyName(key);
                }
                this.onBeforeObjectSerialization &&
                    this.onBeforeObjectSerialization(value);
                this.onStartObjectSerialization &&
                    this.onStartObjectSerialization(value, this);
                serializerMethod(this, value);
                this.onAfterObjectSerialization && this.onAfterObjectSerialization(value);
                if (this.writer.length > 0 &&
                    this.writer[this.writer.length - 1] ===
                        FormSerializationWriter.propertySeparator) {
                    //removing the last separator
                    this.writer.pop();
                }
                key && this.writer.push(FormSerializationWriter.propertySeparator);
            }
        };
        this.writeEnumValue = (key, ...values) => {
            if (values.length > 0) {
                const rawValues = values
                    .filter((x) => x !== undefined)
                    .map((x) => `${x}`);
                if (rawValues.length > 0) {
                    this.writeStringValue(key, rawValues.reduce((x, y) => `${x}, ${y}`));
                }
            }
        };
        this.getSerializedContent = () => {
            return this.convertStringToArrayBuffer(this.writer.join(``));
        };
        this.convertStringToArrayBuffer = (str) => {
            const encoder = new TextEncoder();
            const encodedString = encoder.encode(str);
            return encodedString.buffer;
        };
        this.writeAdditionalData = (additionalData) => {
            // Do not use !value here, because value can be `false`.
            if (additionalData === undefined)
                return;
            for (const key in additionalData) {
                this.writeAnyValue(key, additionalData[key]);
            }
        };
        this.writeAnyValue = (key, value) => {
            if (value !== null && value !== undefined) {
                const valueType = typeof value;
                if (valueType === "boolean") {
                    this.writeBooleanValue(key, value);
                }
                else if (valueType === "string") {
                    this.writeStringValue(key, value);
                }
                else if (value instanceof Date) {
                    this.writeDateValue(key, value);
                }
                else if (value instanceof DateOnly) {
                    this.writeDateOnlyValue(key, value);
                }
                else if (value instanceof TimeOnly) {
                    this.writeTimeOnlyValue(key, value);
                }
                else if (value instanceof Duration) {
                    this.writeDurationValue(key, value);
                }
                else if (valueType === "number") {
                    this.writeNumberValue(key, value);
                }
                else {
                    throw new Error(`encountered unknown ${value} value type during serialization ${valueType} for key ${key}`);
                }
            }
            else {
                this.writeNullValue(key);
            }
        };
    }
    writeByteArrayValue(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    key, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    value) {
        throw new Error("serialization of byt arrays is not supported with URI encoding");
    }
}
FormSerializationWriter.propertySeparator = `&`;
