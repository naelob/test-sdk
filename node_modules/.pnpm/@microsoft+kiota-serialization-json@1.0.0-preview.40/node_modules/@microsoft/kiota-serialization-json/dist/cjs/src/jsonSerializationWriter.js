"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerializationWriter = void 0;
/* eslint-disable @typescript-eslint/no-unused-expressions */
const kiota_abstractions_1 = require("@microsoft/kiota-abstractions");
class JsonSerializationWriter {
    constructor() {
        this.writer = [];
        this.writeStringValue = (key, value) => {
            key && value && this.writePropertyName(key);
            value && this.writer.push(JSON.stringify(value));
            key && value && this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writePropertyName = (key) => {
            this.writer.push(`"${key}":`);
        };
        this.writeBooleanValue = (key, value) => {
            const isValuePresent = value !== null && value !== undefined;
            key && isValuePresent && this.writePropertyName(key);
            isValuePresent && this.writer.push(`${value}`);
            key &&
                isValuePresent &&
                this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writeNumberValue = (key, value) => {
            key && value && this.writePropertyName(key);
            value && this.writer.push(`${value}`);
            key && value && this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writeGuidValue = (key, value) => {
            key && value && this.writePropertyName(key);
            value && this.writer.push(`"${value}"`);
            key && value && this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writeDateValue = (key, value) => this.writeStringValue(key, value === null || value === void 0 ? void 0 : value.toISOString());
        this.writeDateOnlyValue = (key, value) => this.writeStringValue(key, value === null || value === void 0 ? void 0 : value.toString());
        this.writeTimeOnlyValue = (key, value) => this.writeStringValue(key, value === null || value === void 0 ? void 0 : value.toString());
        this.writeDurationValue = (key, value) => this.writeStringValue(key, value === null || value === void 0 ? void 0 : value.toString());
        this.writeNullValue = (key) => {
            key && this.writePropertyName(key);
            this.writer.push(`null`);
            key && this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writeCollectionOfPrimitiveValues = (key, values) => {
            if (values) {
                key && this.writePropertyName(key);
                this.writer.push(`[`);
                values.forEach((v, idx) => {
                    this.writeAnyValue(undefined, v);
                    idx + 1 < values.length &&
                        this.writer.push(JsonSerializationWriter.propertySeparator);
                });
                this.writer.push(`]`);
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeCollectionOfObjectValues = (key, values, serializerMethod) => {
            if (values) {
                key && this.writePropertyName(key);
                this.writer.push(`[`);
                values.forEach((v) => {
                    this.writeObjectValue(undefined, v, serializerMethod);
                    this.writer.push(JsonSerializationWriter.propertySeparator);
                });
                if (values.length > 0) {
                    //removing the last separator
                    this.writer.pop();
                }
                this.writer.push(`]`);
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeEnumValue = (key, ...values) => {
            if (values.length > 0) {
                const rawValues = values
                    .filter((x) => x !== undefined)
                    .map((x) => `${x}`);
                if (rawValues.length > 0) {
                    this.writeStringValue(key, rawValues.reduce((x, y) => `${x}, ${y}`));
                }
            }
        };
        this.getSerializedContent = () => {
            return this.convertStringToArrayBuffer(this.writer.join(``));
        };
        this.convertStringToArrayBuffer = (str) => {
            const encoder = new TextEncoder();
            const encodedString = encoder.encode(str);
            return encodedString.buffer;
        };
        this.writeAdditionalData = (additionalData) => {
            // !value will fail to serialize false and null values which can be valid input
            if (additionalData === undefined)
                return;
            for (const key in additionalData) {
                this.writeAnyValue(key, additionalData[key]);
            }
        };
        this.writeNonParsableObjectValue = (key, value) => {
            if (key) {
                this.writePropertyName(key);
            }
            this.writer.push(JSON.stringify(value), JsonSerializationWriter.propertySeparator);
        };
        this.writeAnyValue = (key, value) => {
            if (value !== undefined && value !== null) {
                const valueType = typeof value;
                if (valueType === "boolean") {
                    this.writeBooleanValue(key, value);
                }
                else if (valueType === "string") {
                    this.writeStringValue(key, value);
                }
                else if (value instanceof Date) {
                    this.writeDateValue(key, value);
                }
                else if (value instanceof kiota_abstractions_1.DateOnly) {
                    this.writeDateOnlyValue(key, value);
                }
                else if (value instanceof kiota_abstractions_1.TimeOnly) {
                    this.writeTimeOnlyValue(key, value);
                }
                else if (value instanceof kiota_abstractions_1.Duration) {
                    this.writeDurationValue(key, value);
                }
                else if (valueType === "number") {
                    this.writeNumberValue(key, value);
                }
                else if (Array.isArray(value)) {
                    this.writeCollectionOfPrimitiveValues(key, value);
                }
                else if (valueType === "object") {
                    this.writeNonParsableObjectValue(key, value);
                }
                else {
                    throw new Error(`encountered unknown value type during serialization ${valueType}`);
                }
            }
            else {
                this.writeNullValue(key);
            }
        };
    }
    writeByteArrayValue(key, value) {
        if (!value) {
            throw new Error("value cannot be undefined");
        }
        const b64 = Buffer.from(value).toString("base64");
        this.writeStringValue(key, b64);
    }
    writeObjectValue(key, value, serializerMethod) {
        if (key) {
            this.writePropertyName(key);
        }
        this.onBeforeObjectSerialization &&
            this.onBeforeObjectSerialization(value);
        this.writer.push(`{`);
        this.onStartObjectSerialization &&
            this.onStartObjectSerialization(value, this);
        value && serializerMethod && serializerMethod(this, value);
        this.onAfterObjectSerialization &&
            this.onAfterObjectSerialization(value);
        if (this.writer.length > 0 &&
            this.writer[this.writer.length - 1] ===
                JsonSerializationWriter.propertySeparator) {
            //removing the last separator
            this.writer.pop();
        }
        this.writer.push(`}`);
        key && this.writer.push(JsonSerializationWriter.propertySeparator);
    }
}
exports.JsonSerializationWriter = JsonSerializationWriter;
JsonSerializationWriter.propertySeparator = `,`;
