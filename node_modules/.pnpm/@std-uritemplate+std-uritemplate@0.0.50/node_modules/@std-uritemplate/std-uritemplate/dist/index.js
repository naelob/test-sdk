"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdUriTemplate = void 0;
var Operator;
(function (Operator) {
    Operator[Operator["NO_OP"] = 0] = "NO_OP";
    Operator[Operator["PLUS"] = 1] = "PLUS";
    Operator[Operator["HASH"] = 2] = "HASH";
    Operator[Operator["DOT"] = 3] = "DOT";
    Operator[Operator["SLASH"] = 4] = "SLASH";
    Operator[Operator["SEMICOLON"] = 5] = "SEMICOLON";
    Operator[Operator["QUESTION_MARK"] = 6] = "QUESTION_MARK";
    Operator[Operator["AMP"] = 7] = "AMP";
})(Operator || (Operator = {}));
var SubstitutionType;
(function (SubstitutionType) {
    SubstitutionType[SubstitutionType["EMPTY"] = 0] = "EMPTY";
    SubstitutionType[SubstitutionType["STRING"] = 1] = "STRING";
    SubstitutionType[SubstitutionType["LIST"] = 2] = "LIST";
    SubstitutionType[SubstitutionType["MAP"] = 3] = "MAP";
})(SubstitutionType || (SubstitutionType = {}));
class StdUriTemplate {
    static expand(template, substitutions) {
        return StdUriTemplate.expandImpl(template, substitutions);
    }
    static validateLiteral(c, col) {
        switch (c) {
            case '+':
            case '#':
            case '/':
            case ';':
            case '?':
            case '&':
            case ' ':
            case '!':
            case '=':
            case '$':
            case '|':
            case '*':
            case ':':
            case '~':
            case '-':
                throw new Error(`Illegal character identified in the token at col: ${col}`);
            default:
                break;
        }
    }
    static getMaxChar(buffer, col) {
        if (!buffer) {
            return -1;
        }
        else {
            const value = buffer.join('');
            if (value.length === 0) {
                return -1;
            }
            else {
                try {
                    return parseInt(value, 10);
                }
                catch (e) {
                    throw new Error(`Cannot parse max chars at col: ${col}`);
                }
            }
        }
    }
    static getOperator(c, token, col) {
        switch (c) {
            case '+':
                return Operator.PLUS;
            case '#':
                return Operator.HASH;
            case '.':
                return Operator.DOT;
            case '/':
                return Operator.SLASH;
            case ';':
                return Operator.SEMICOLON;
            case '?':
                return Operator.QUESTION_MARK;
            case '&':
                return Operator.AMP;
            default:
                StdUriTemplate.validateLiteral(c, col);
                token.push(c);
                return Operator.NO_OP;
        }
    }
    static expandImpl(str, substitutions) {
        const result = [];
        let token = null;
        let operator = null;
        let composite = false;
        let maxCharBuffer = null;
        let firstToken = true;
        for (let i = 0; i < str.length; i++) {
            const character = str.charAt(i);
            switch (character) {
                case '{':
                    token = [];
                    firstToken = true;
                    break;
                case '}':
                    if (token !== null) {
                        const expanded = StdUriTemplate.expandToken(operator, token.join(''), composite, StdUriTemplate.getMaxChar(maxCharBuffer, i), firstToken, substitutions, result, i);
                        if (expanded && firstToken) {
                            firstToken = false;
                        }
                        token = null;
                        operator = null;
                        composite = false;
                        maxCharBuffer = null;
                    }
                    else {
                        throw new Error(`Failed to expand token, invalid at col: ${i}`);
                    }
                    break;
                case ',':
                    if (token !== null) {
                        const expanded = StdUriTemplate.expandToken(operator, token.join(''), composite, StdUriTemplate.getMaxChar(maxCharBuffer, i), firstToken, substitutions, result, i);
                        if (expanded && firstToken) {
                            firstToken = false;
                        }
                        token = [];
                        composite = false;
                        maxCharBuffer = null;
                        break;
                    }
                // Intentional fall-through for commas outside the {}
                default:
                    if (token !== null) {
                        if (operator === null) {
                            operator = StdUriTemplate.getOperator(character, token, i);
                        }
                        else if (maxCharBuffer !== null) {
                            if (character.match(/^\d$/)) {
                                maxCharBuffer.push(character);
                            }
                            else {
                                throw new Error(`Illegal character identified in the token at col: ${i}`);
                            }
                        }
                        else {
                            if (character === ':') {
                                maxCharBuffer = [];
                            }
                            else if (character === '*') {
                                composite = true;
                            }
                            else {
                                StdUriTemplate.validateLiteral(character, i);
                                token.push(character);
                            }
                        }
                    }
                    else {
                        result.push(character);
                    }
                    break;
            }
        }
        if (token === null) {
            return result.join('');
        }
        else {
            throw new Error('Unterminated token');
        }
    }
    static addPrefix(op, result) {
        switch (op) {
            case Operator.HASH:
                result.push('#');
                break;
            case Operator.DOT:
                result.push('.');
                break;
            case Operator.SLASH:
                result.push('/');
                break;
            case Operator.SEMICOLON:
                result.push(';');
                break;
            case Operator.QUESTION_MARK:
                result.push('?');
                break;
            case Operator.AMP:
                result.push('&');
                break;
            default:
                return;
        }
    }
    static addSeparator(op, result) {
        switch (op) {
            case Operator.DOT:
                result.push('.');
                break;
            case Operator.SLASH:
                result.push('/');
                break;
            case Operator.SEMICOLON:
                result.push(';');
                break;
            case Operator.QUESTION_MARK:
            case Operator.AMP:
                result.push('&');
                break;
            default:
                result.push(',');
                return;
        }
    }
    static addValue(op, token, value, result, maxChar) {
        switch (op) {
            case Operator.PLUS:
            case Operator.HASH:
                StdUriTemplate.addExpandedValue(null, value, result, maxChar, false);
                break;
            case Operator.QUESTION_MARK:
            case Operator.AMP:
                result.push(`${token}=`);
                StdUriTemplate.addExpandedValue(null, value, result, maxChar, true);
                break;
            case Operator.SEMICOLON:
                result.push(token);
                StdUriTemplate.addExpandedValue('=', value, result, maxChar, true);
                break;
            case Operator.DOT:
            case Operator.SLASH:
            case Operator.NO_OP:
                StdUriTemplate.addExpandedValue(null, value, result, maxChar, true);
                break;
        }
    }
    static addValueElement(op, token, value, result, maxChar) {
        switch (op) {
            case Operator.PLUS:
            case Operator.HASH:
                StdUriTemplate.addExpandedValue(null, value, result, maxChar, false);
                break;
            case Operator.QUESTION_MARK:
            case Operator.AMP:
            case Operator.SEMICOLON:
            case Operator.DOT:
            case Operator.SLASH:
            case Operator.NO_OP:
                StdUriTemplate.addExpandedValue(null, value, result, maxChar, true);
                break;
        }
    }
    static isSurrogate(cp) {
        const codeUnit = cp.charCodeAt(0);
        return (codeUnit >= 0xD800 && codeUnit <= 0xDBFF);
    }
    static isIprivate(cp) {
        return 0xE000 <= cp.charCodeAt(0) && cp.charCodeAt(0) <= 0xF8FF;
    }
    static isUcschar(cp) {
        const codePoint = cp.codePointAt(0) || 0;
        return (0xA0 <= codePoint && codePoint <= 0xD7FF) ||
            (0xF900 <= codePoint && codePoint <= 0xFDCF) ||
            (0xFDF0 <= codePoint && codePoint <= 0xFFEF);
    }
    static addExpandedValue(prefix, value, result, maxChar, replaceReserved) {
        const stringValue = StdUriTemplate.convertNativeTypes(value);
        const max = maxChar !== -1 ? Math.min(maxChar, stringValue.length) : stringValue.length;
        let reservedBuffer = undefined;
        if (max > 0 && prefix != null) {
            result.push(prefix);
        }
        for (let i = 0; i < max; i++) {
            const character = stringValue.charAt(i);
            if (character === '%' && !replaceReserved) {
                reservedBuffer = [];
            }
            let toAppend = Buffer.from(character, 'utf-8').toString();
            if (StdUriTemplate.isSurrogate(character)) {
                toAppend = encodeURIComponent(stringValue.charAt(i) + stringValue.charAt(i + 1));
                i++; // Skip the next character
            }
            else if (replaceReserved || StdUriTemplate.isUcschar(character) || StdUriTemplate.isIprivate(character)) {
                if (character === '!') { // Specific to JS/TS: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent#description
                    toAppend = '%21';
                }
                else {
                    toAppend = encodeURIComponent(toAppend);
                }
            }
            if (reservedBuffer) {
                reservedBuffer.push(toAppend);
                if (reservedBuffer.length === 3) {
                    let isEncoded = false;
                    try {
                        const reserved = reservedBuffer.join('');
                        const decoded = decodeURIComponent(reservedBuffer.join(''));
                        isEncoded = (reserved !== decoded);
                    }
                    catch (e) {
                        // ignore
                    }
                    if (isEncoded) {
                        result.push(reservedBuffer.join(''));
                    }
                    else {
                        result.push('%25');
                        // only if !replaceReserved
                        result.push(reservedBuffer.slice(1).join(''));
                    }
                    reservedBuffer = undefined;
                }
            }
            else {
                if (character === ' ') {
                    result.push('%20');
                }
                else if (character === '%') {
                    result.push('%25');
                }
                else {
                    result.push(toAppend);
                }
            }
        }
        if (reservedBuffer) {
            result.push('%25');
            result.push(reservedBuffer.slice(1).join(''));
        }
    }
    static isList(value) {
        return Array.isArray(value) || value instanceof Set;
    }
    static isMap(value) {
        return value instanceof Map || typeof value === 'object';
    }
    static getSubstitutionType(value, col) {
        if (value === undefined || value === null) {
            return SubstitutionType.EMPTY;
        }
        else if (StdUriTemplate.isNativeType(value)) {
            return SubstitutionType.STRING;
        }
        else if (StdUriTemplate.isList(value)) {
            return SubstitutionType.LIST;
        }
        else if (StdUriTemplate.isMap(value)) {
            return SubstitutionType.MAP;
        }
        else {
            throw new Error(`Illegal class passed as substitution, found ${typeof value} at col: ${col}`);
        }
    }
    static isEmpty(substType, value) {
        if (value === undefined || value === null) {
            return true;
        }
        else {
            switch (substType) {
                case SubstitutionType.STRING:
                    return false;
                case SubstitutionType.LIST:
                    return value.length === 0;
                case SubstitutionType.MAP:
                    return Object.keys(value).length === 0;
                default:
                    return true;
            }
        }
    }
    static isNativeType(value) {
        return (typeof value === 'string' ||
            typeof value === 'number' ||
            typeof value === 'boolean' ||
            value instanceof Date);
    }
    static convertNativeTypes(value) {
        if (typeof value === 'string') {
            return value;
        }
        else if (typeof value === 'number' || typeof value === 'boolean') {
            return value.toString();
        }
        else if (value instanceof Date) {
            return value.toISOString().split('.')[0] + "Z";
        }
        else {
            throw new Error(`Illegal class passed as substitution, found ${typeof value}`);
        }
    }
    static expandToken(operator, token, composite, maxChar, firstToken, substitutions, result, col) {
        if (token.length === 0) {
            throw new Error(`Found an empty token at col: ${col}`);
        }
        const value = substitutions[token];
        const substType = StdUriTemplate.getSubstitutionType(value, col);
        if (substType === SubstitutionType.EMPTY || StdUriTemplate.isEmpty(substType, value)) {
            return false;
        }
        if (firstToken) {
            StdUriTemplate.addPrefix(operator, result);
        }
        else {
            StdUriTemplate.addSeparator(operator, result);
        }
        switch (substType) {
            case SubstitutionType.STRING:
                StdUriTemplate.addStringValue(operator, token, value, result, maxChar);
                break;
            case SubstitutionType.LIST:
                StdUriTemplate.addListValue(operator, token, value, result, maxChar, composite);
                break;
            case SubstitutionType.MAP:
                StdUriTemplate.addMapValue(operator, token, value, result, maxChar, composite);
                break;
        }
        return true;
    }
    static addStringValue(operator, token, value, result, maxChar) {
        StdUriTemplate.addValue(operator, token, value, result, maxChar);
    }
    static addListValue(operator, token, value, result, maxChar, composite) {
        let first = true;
        for (const v of value) {
            if (first) {
                StdUriTemplate.addValue(operator, token, v, result, maxChar);
                first = false;
            }
            else {
                if (composite) {
                    StdUriTemplate.addSeparator(operator, result);
                    StdUriTemplate.addValue(operator, token, v, result, maxChar);
                }
                else {
                    result.push(',');
                    StdUriTemplate.addValueElement(operator, token, v, result, maxChar);
                }
            }
        }
    }
    static addMapValue(operator, token, value, result, maxChar, composite) {
        let first = true;
        if (maxChar !== -1) {
            throw new Error('Value trimming is not allowed on Maps');
        }
        for (const key in value) {
            const v = value[key];
            if (composite) {
                if (!first) {
                    StdUriTemplate.addSeparator(operator, result);
                }
                StdUriTemplate.addValueElement(operator, token, key, result, maxChar);
                result.push('=');
            }
            else {
                if (first) {
                    StdUriTemplate.addValue(operator, token, key, result, maxChar);
                }
                else {
                    result.push(',');
                    StdUriTemplate.addValueElement(operator, token, key, result, maxChar);
                }
                result.push(',');
            }
            StdUriTemplate.addValueElement(operator, token, v, result, maxChar);
            first = false;
        }
    }
}
exports.StdUriTemplate = StdUriTemplate;
